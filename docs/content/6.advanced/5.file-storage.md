---
title: File Storage
description: Upload and manage files with Convex storage and Nuxt.
navigation:
  icon: i-lucide-upload
---

# File Storage

Upload, store, and serve files using Convex's built-in file storage with Nuxt.

::callout{icon="i-lucide-info" to="https://docs.convex.dev/file-storage" target="\_blank"}
Convex provides built-in file storage. See the [Convex File Storage docs](https://docs.convex.dev/file-storage) for backend details.
::

---

## Overview

File uploads in Convex follow this flow:

```
┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│   Frontend  │    │    Convex    │    │   Storage   │
│   (Nuxt)    │    │   (Action)   │    │   (Blob)    │
└──────┬──────┘    └──────┬───────┘    └──────┬──────┘
       │                  │                   │
       │ 1. Request URL   │                   │
       │─────────────────>│                   │
       │                  │                   │
       │ 2. Upload URL    │                   │
       │<─────────────────│                   │
       │                  │                   │
       │ 3. Upload file directly              │
       │─────────────────────────────────────>│
       │                  │                   │
       │ 4. Storage ID    │                   │
       │<─────────────────────────────────────│
       │                  │                   │
       │ 5. Save metadata │                   │
       │─────────────────>│                   │
       │                  │                   │
```

---

## Backend Setup

### Generate Upload URL

Create an action to generate upload URLs:

```ts [convex/files.ts]
import { mutation, action, query } from './_generated/server'
import { v } from 'convex/values'

// Generate a short-lived upload URL
export const generateUploadUrl = action({
  handler: async (ctx) => {
    return await ctx.storage.generateUploadUrl()
  },
})

// Save file metadata after upload
export const saveFile = mutation({
  args: {
    storageId: v.id('_storage'),
    fileName: v.string(),
    fileType: v.string(),
    fileSize: v.number(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) throw new Error('Unauthorized')

    return await ctx.db.insert('files', {
      storageId: args.storageId,
      fileName: args.fileName,
      fileType: args.fileType,
      fileSize: args.fileSize,
      uploadedBy: identity.subject,
      createdAt: Date.now(),
    })
  },
})

// Get file URL for display
export const getFileUrl = query({
  args: { storageId: v.id('_storage') },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId)
  },
})

// List user's files
export const listFiles = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) return []

    const files = await ctx.db
      .query('files')
      .filter(q => q.eq(q.field('uploadedBy'), identity.subject))
      .order('desc')
      .collect()

    // Attach URLs to each file
    return Promise.all(
      files.map(async (file) => ({
        ...file,
        url: await ctx.storage.getUrl(file.storageId),
      }))
    )
  },
})
```

### Schema

```ts [convex/schema.ts]
import { defineSchema, defineTable } from 'convex/server'
import { v } from 'convex/values'

export default defineSchema({
  files: defineTable({
    storageId: v.id('_storage'),
    fileName: v.string(),
    fileType: v.string(),
    fileSize: v.number(),
    uploadedBy: v.string(),
    createdAt: v.number(),
  })
    .index('by_user', ['uploadedBy']),
})
```

---

## Frontend Upload

### Basic File Upload

```vue [components/FileUpload.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const { execute: getUploadUrl, pending: gettingUrl } = useConvexAction(
  api.files.generateUploadUrl
)
const { mutate: saveFile, pending: saving } = useConvexMutation(api.files.saveFile)

const uploading = ref(false)
const progress = ref(0)
const error = ref<string | null>(null)

const isLoading = computed(() => gettingUrl.value || uploading.value || saving.value)

async function handleFileChange(event: Event) {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  if (!file) return

  error.value = null
  uploading.value = true
  progress.value = 0

  try {
    // 1. Get upload URL from Convex
    const uploadUrl = await getUploadUrl({})

    // 2. Upload file directly to Convex storage
    const result = await fetch(uploadUrl, {
      method: 'POST',
      headers: { 'Content-Type': file.type },
      body: file,
    })

    if (!result.ok) {
      throw new Error('Upload failed')
    }

    const { storageId } = await result.json()

    // 3. Save file metadata
    await saveFile({
      storageId,
      fileName: file.name,
      fileType: file.type,
      fileSize: file.size,
    })

    // 4. Clear input
    input.value = ''
    progress.value = 100
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'Upload failed'
  } finally {
    uploading.value = false
  }
}
</script>

<template>
  <div class="file-upload">
    <input
      type="file"
      :disabled="isLoading"
      @change="handleFileChange"
    />

    <div v-if="isLoading" class="progress">
      <span v-if="gettingUrl">Preparing upload...</span>
      <span v-else-if="uploading">Uploading...</span>
      <span v-else-if="saving">Saving...</span>
    </div>

    <p v-if="error" class="error">{{ error }}</p>
  </div>
</template>
```

### With Progress Tracking

For large files, track upload progress using `XMLHttpRequest`:

```vue [components/FileUploadWithProgress.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const { execute: getUploadUrl } = useConvexAction(api.files.generateUploadUrl)
const { mutate: saveFile } = useConvexMutation(api.files.saveFile)

const progress = ref(0)
const uploading = ref(false)
const error = ref<string | null>(null)

async function uploadFile(file: File): Promise<string> {
  const uploadUrl = await getUploadUrl({})

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()

    xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable) {
        progress.value = Math.round((event.loaded / event.total) * 100)
      }
    })

    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        const { storageId } = JSON.parse(xhr.responseText)
        resolve(storageId)
      } else {
        reject(new Error('Upload failed'))
      }
    })

    xhr.addEventListener('error', () => reject(new Error('Network error')))

    xhr.open('POST', uploadUrl)
    xhr.setRequestHeader('Content-Type', file.type)
    xhr.send(file)
  })
}

async function handleFileChange(event: Event) {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  if (!file) return

  error.value = null
  uploading.value = true
  progress.value = 0

  try {
    const storageId = await uploadFile(file)

    await saveFile({
      storageId,
      fileName: file.name,
      fileType: file.type,
      fileSize: file.size,
    })

    input.value = ''
  } catch (e) {
    error.value = e instanceof Error ? e.message : 'Upload failed'
  } finally {
    uploading.value = false
  }
}
</script>

<template>
  <div class="upload">
    <input type="file" @change="handleFileChange" :disabled="uploading" />

    <div v-if="uploading" class="progress-bar">
      <div class="progress-fill" :style="{ width: `${progress}%` }" />
      <span>{{ progress }}%</span>
    </div>

    <p v-if="error" class="error">{{ error }}</p>
  </div>
</template>

<style scoped>
.progress-bar {
  width: 100%;
  height: 20px;
  background: #e5e7eb;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}
.progress-fill {
  height: 100%;
  background: #3b82f6;
  transition: width 0.2s;
}
.progress-bar span {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
}
</style>
```

---

## Display Files

### Image Display

```vue [components/FileGallery.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const { data: files } = await useConvexQuery(api.files.listFiles, {})
</script>

<template>
  <div class="gallery">
    <div v-for="file in files" :key="file._id" class="file-card">
      <!-- Image preview -->
      <img
        v-if="file.fileType.startsWith('image/')"
        :src="file.url"
        :alt="file.fileName"
        loading="lazy"
      />

      <!-- Non-image file -->
      <div v-else class="file-icon">
        <span>{{ file.fileType.split('/')[1] }}</span>
      </div>

      <div class="file-info">
        <p class="name">{{ file.fileName }}</p>
        <p class="size">{{ formatFileSize(file.fileSize) }}</p>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
}
</script>
```

### Download Link

```vue
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const props = defineProps<{
  storageId: string
  fileName: string
}>()

const { data: url } = await useConvexQuery(
  api.files.getFileUrl,
  computed(() => ({ storageId: props.storageId }))
)
</script>

<template>
  <a v-if="url" :href="url" :download="fileName" class="download-link">
    Download {{ fileName }}
  </a>
</template>
```

---

## Image Upload with Preview

```vue [components/ImageUpload.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const { execute: getUploadUrl } = useConvexAction(api.files.generateUploadUrl)
const { mutate: saveFile } = useConvexMutation(api.files.saveFile)

const preview = ref<string | null>(null)
const uploading = ref(false)

function handleFileSelect(event: Event) {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  if (!file) return

  // Validate image
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file')
    return
  }

  // Create preview
  const reader = new FileReader()
  reader.onload = (e) => {
    preview.value = e.target?.result as string
  }
  reader.readAsDataURL(file)
}

async function uploadImage() {
  const input = document.querySelector('input[type="file"]') as HTMLInputElement
  const file = input?.files?.[0]
  if (!file) return

  uploading.value = true

  try {
    const uploadUrl = await getUploadUrl({})

    const result = await fetch(uploadUrl, {
      method: 'POST',
      headers: { 'Content-Type': file.type },
      body: file,
    })

    const { storageId } = await result.json()

    await saveFile({
      storageId,
      fileName: file.name,
      fileType: file.type,
      fileSize: file.size,
    })

    preview.value = null
    input.value = ''
  } finally {
    uploading.value = false
  }
}

function clearPreview() {
  preview.value = null
  const input = document.querySelector('input[type="file"]') as HTMLInputElement
  if (input) input.value = ''
}
</script>

<template>
  <div class="image-upload">
    <div v-if="!preview" class="drop-zone">
      <input
        type="file"
        accept="image/*"
        @change="handleFileSelect"
      />
      <p>Click or drag to upload an image</p>
    </div>

    <div v-else class="preview">
      <img :src="preview" alt="Preview" />
      <div class="actions">
        <button @click="uploadImage" :disabled="uploading">
          {{ uploading ? 'Uploading...' : 'Upload' }}
        </button>
        <button @click="clearPreview" :disabled="uploading">
          Cancel
        </button>
      </div>
    </div>
  </div>
</template>
```

---

## Delete Files

```ts [convex/files.ts]
export const deleteFile = mutation({
  args: { id: v.id('files') },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) throw new Error('Unauthorized')

    const file = await ctx.db.get(args.id)
    if (!file) throw new Error('File not found')

    // Check ownership
    if (file.uploadedBy !== identity.subject) {
      throw new Error('Forbidden')
    }

    // Delete from storage
    await ctx.storage.delete(file.storageId)

    // Delete metadata
    await ctx.db.delete(args.id)
  },
})
```

```vue
<script setup lang="ts">
const { mutate: deleteFile, pending } = useConvexMutation(api.files.deleteFile)

async function handleDelete(fileId: string) {
  if (confirm('Delete this file?')) {
    await deleteFile({ id: fileId })
  }
}
</script>

<template>
  <button @click="handleDelete(file._id)" :disabled="pending">
    Delete
  </button>
</template>
```

---

## File Validation

Validate files before upload:

```ts
const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf']

function validateFile(file: File): string | null {
  if (file.size > MAX_FILE_SIZE) {
    return `File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`
  }

  if (!ALLOWED_TYPES.includes(file.type)) {
    return `File type not allowed. Allowed types: ${ALLOWED_TYPES.join(', ')}`
  }

  return null
}

// Usage
async function handleFileChange(event: Event) {
  const file = (event.target as HTMLInputElement).files?.[0]
  if (!file) return

  const validationError = validateFile(file)
  if (validationError) {
    error.value = validationError
    return
  }

  // Proceed with upload...
}
```

---

## Related Topics

- [Actions](/mutations/actions) - Using useConvexAction for upload URLs
- [Mutations](/mutations/mutations) - Saving file metadata
- [Queries](/data-fetching/queries) - Loading file lists
