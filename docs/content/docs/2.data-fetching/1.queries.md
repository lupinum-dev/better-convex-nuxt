---
title: Fetching Data
description: Query data with SSR support, real-time subscriptions, and reactive state management.
navigation:
  icon: i-lucide-database
---

## Basic Usage

```vue
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

// Fetch posts with SSR and real-time updates
const { data: posts } = await useConvexQuery(api.posts.list, {})
</script>

<template>
  <PostCard v-for="post in posts" :key="post._id" :post="post" />
</template>
```

The `await` blocks navigation until data loads. Data is fetched on the server during SSR, then syncs in real-time via WebSocket.

::callout{icon="i-lucide-info"}
**Client vs Server**: `useConvexQuery` is for Vue components. For server routes (`server/api/`), use [`fetchQuery`](/docs/server-side/server-routes) instead.
::

---

## Passing Arguments

The second parameter is the arguments object. Pass values that match your Convex query's `args`:

```ts
// Convex query definition
export const getById = query({
  args: { id: v.id('posts') },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id)
  },
})
```

```ts
// In your Vue component
const { data: post } = await useConvexQuery(
  api.posts.getById,
  { id: 'abc123' }  // Pass the required args
)
```

For queries with no arguments, pass an empty object `{}`:

```ts
const { data: posts } = await useConvexQuery(api.posts.list, {})
```

---

## Reactive Arguments

When arguments come from reactive sources (refs, route params), wrap them in `computed()`. The query re-executes automatically when values change:

```ts
// From route params
const route = useRoute()

const { data: post } = await useConvexQuery(
  api.posts.getBySlug,
  computed(() => ({ slug: route.params.slug as string }))
)
```

```ts
// From a ref
const categoryId = ref('tech')

const { data } = await useConvexQuery(
  api.posts.byCategory,
  computed(() => ({ categoryId: categoryId.value }))
)

// Changing categoryId triggers a new query
categoryId.value = 'design'
```

---

## Loading States

Use `status` to handle all query states:

```vue
<script setup lang="ts">
const { data: posts, status, error } = await useConvexQuery(api.posts.list, {})
</script>

<template>
  <div v-if="status === 'idle'">Select a category</div>
  <div v-else-if="status === 'pending'">Loading...</div>
  <div v-else-if="status === 'error'">{{ error?.message }}</div>
  <div v-else-if="status === 'success' && !posts?.length">No posts</div>
  <div v-else>
    <PostCard v-for="post in posts" :key="post._id" :post="post" />
  </div>
</template>
```

| Status      | Meaning                            |
| ----------- | ---------------------------------- |
| `'idle'`    | Query is skipped (args = `'skip'`) |
| `'pending'` | Waiting for data                   |
| `'success'` | Data received                      |
| `'error'`   | Query failed                       |

---

## Lazy Loading

By default, `await useConvexQuery()` blocks navigation until data loads. Use `lazy: true` to render immediately with a loading state:

```ts
const { data, pending } = await useConvexQuery(
  api.posts.list,
  {},
  { lazy: true }
)
```

```vue
<template>
  <div v-if="pending">Loading...</div>
  <PostList v-else :posts="data" />
</template>
```

For convenience, you can use `useLazyConvexQuery()` which is equivalent to `useConvexQuery(..., { lazy: true })`:

```ts
// These are equivalent:
const query1 = useLazyConvexQuery(api.posts.list, {})
const query2 = useConvexQuery(api.posts.list, {}, { lazy: true })
```

### When to Use Lazy Loading

Use `lazy: true` for non-critical data that shouldn't block navigation:

- Secondary content (sidebar, recommendations)
- Below-the-fold content
- Data that can load after the main content

### Example: Main + Secondary Content

```vue
<script setup lang="ts">
// Critical: blocks navigation
const { data: post } = await useConvexQuery(
  api.posts.get,
  computed(() => ({ id: route.params.id }))
)

// Non-critical: loads in background
const { data: related, pending } = useLazyConvexQuery(
  api.posts.getRelated,
  computed(() => ({ postId: route.params.id }))
)
</script>

<template>
  <article>
    <h1>{{ post?.title }}</h1>
    <div v-html="post?.content" />
  </article>

  <aside>
    <h2>Related Posts</h2>
    <div v-if="pending">Loading...</div>
    <PostCard v-else v-for="p in related" :key="p._id" :post="p" />
  </aside>
</template>
```

---

## SSR Behavior

By default, queries run on the server during SSR (like Nuxt's `useFetch`). This means no loading spinners on initial page load.

```ts
const route = useRoute()

// Default behavior - SSR enabled
const { data } = await useConvexQuery(
  api.posts.getBySlug,
  computed(() => ({ slug: route.params.slug as string }))
)
```

### Disable SSR for Specific Queries

For client-only data or performance optimization, disable SSR:

```ts
const { data, status } = await useConvexQuery(
  api.posts.getBySlug,
  computed(() => ({ slug: route.params.slug as string })),
  { server: false } // Client-only, shows loading state on refresh
)
```

### Configure Global Defaults

Change the default for all queries in `nuxt.config.ts`:

```ts
export default defineNuxtConfig({
  convex: {
    defaults: {
      server: false,  // Disable SSR globally
      lazy: true      // Enable lazy loading globally
    }
  }
})
```

See [SSR & Hydration](/docs/server-side/ssr-hydration) for all loading strategy combinations.

---

## Real-time Control

Queries subscribe to real-time updates by default. Use `subscribe: false` for data that doesn't need live updates:

```ts
const { data, refresh } = await useConvexQuery(
  api.config.getSettings,
  {},
  { subscribe: false }
)

// Data won't update automatically
// Use refresh() to manually re-fetch
await refresh()
```

**When to use `subscribe: false`:**

- Configuration/settings that rarely change
- Historical data or reports
- Reducing WebSocket connections
- Search results (use `refresh()` on search)

---

## Skipping Queries

Use `'skip'` to conditionally disable a query:

```ts
const { isAuthenticated } = useConvexAuth()

const { data: profile, status } = await useConvexQuery(
  api.users.getProfile,
  computed(() => isAuthenticated.value ? {} : 'skip')
)

// status === 'idle' when skipped
```

---

## Transform Data

Transform data after fetching to add computed fields:

```ts
const { data: posts } = await useConvexQuery(
  api.posts.list,
  {},
  {
    transform: (posts) => posts?.map(post => ({
      ...post,
      formattedDate: new Date(post.publishedAt).toLocaleDateString(),
      readingTime: Math.ceil(post.content.split(' ').length / 200) + ' min read',
      excerpt: post.content.slice(0, 150) + '...',
    }))
  }
)

// posts now has formattedDate, readingTime, excerpt fields!
```

The transform runs on:

- SSR fetch result
- Every WebSocket subscription update
- Manual `refresh()` calls

### Type-Safe Transforms

Transform can change the data shape. TypeScript infers the new type:

```ts
const { data } = await useConvexQuery(
  api.posts.list,
  {},
  {
    transform: (posts) => posts?.map(p => ({
      ...p,
      formattedDate: formatDate(p.publishedAt)
    }))
  }
)

// data.value?.[0].formattedDate is typed as string
```

---

## Default Data

Provide placeholder data while loading:

```ts
const { data: posts } = await useConvexQuery(
  api.posts.list,
  {},
  { default: () => [] }
)

// posts is [] while loading, then real data
```

---

## Manual Refresh

Re-fetch data on demand:

```ts
const { data, refresh } = await useConvexQuery(api.posts.list, {})

async function handleRefresh() {
  await refresh()
}
```

---

## Clear State

Reset to initial state:

```ts
const { data, clear } = await useConvexQuery(api.posts.list, {})

function handleClear() {
  clear() // data = null, status = 'idle'
}
```

---

## Public Queries

Skip auth token overhead for public data:

```ts
const { data } = await useConvexQuery(
  api.posts.featured,
  {},
  { public: true }
)
```

---

## TypeScript

Full type inference from your Convex schema:

```ts
import { api } from '~/convex/_generated/api'

// Args and return type are inferred
const { data: posts } = await useConvexQuery(api.posts.list, {})
// posts is Ref<Post[] | null>

posts.value?.map(post => post.title) // post is typed
```

---

## API Reference

### Parameters

| Parameter | Type                         | Description                                       |
| --------- | ---------------------------- | ------------------------------------------------- |
| `query`   | `FunctionReference<"query">` | Convex query function reference                   |
| `args`    | `MaybeRef<Args \| 'skip'>`   | Query arguments (reactive) or `'skip'` to disable |
| `options` | `UseConvexQueryOptions`      | Optional configuration                            |

### Options

| Option      | Type               | Default     | Description                                       |
| ----------- | ------------------ | ----------- | ------------------------------------------------- |
| `lazy`      | `boolean`          | `false`     | Don't block navigation, load in background        |
| `server`    | `boolean`          | `true`      | Run query on server during SSR                    |
| `subscribe` | `boolean`          | `true`      | Subscribe to real-time updates via WebSocket      |
| `default`   | `() => T`          | `undefined` | Factory for initial/placeholder data              |
| `transform` | `(raw: RawT) => T` | `undefined` | Transform data after fetching                     |
| `public`    | `boolean`          | `false`     | Skip auth checks for public queries               |

::note
All options can be configured globally via `convex.defaults` in `nuxt.config.ts`. Per-query options override global defaults.
::

### Return Values

| Property  | Type                       | Description                                         |
| --------- | -------------------------- | --------------------------------------------------- |
| `data`    | `Ref<T \| null>`           | Query result (`null` when skipped or not yet loaded)|
| `status`  | `ComputedRef<QueryStatus>` | `'idle'` \| `'pending'` \| `'success'` \| `'error'` |
| `pending` | `ComputedRef<boolean>`     | Shorthand for `status === 'pending'`                |
| `error`   | `Ref<Error \| null>`       | Error if query failed                               |
| `refresh` | `() => Promise<void>`      | Re-fetch data via HTTP                              |
| `execute` | `() => Promise<void>`      | Alias for `refresh`                                 |
| `clear`   | `() => void`               | Reset state to initial values                       |

---

## Related Topics

- [Pagination](/docs/data-fetching/pagination) - Load More and infinite scroll
- [Caching & Data Reuse](/docs/data-fetching/caching-reuse) - Instant navigation with cached data
- [SSR & Hydration](/docs/server-side/ssr-hydration) - Server rendering patterns
- [Performance](/docs/advanced/performance) - Optimization strategies
