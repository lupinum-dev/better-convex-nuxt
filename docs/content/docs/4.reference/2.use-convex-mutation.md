---
title: useConvexMutation
description: Modify data with optimistic updates.
navigation:
  icon: i-lucide-edit
---

Execute Convex mutations with status tracking and optional optimistic updates.

## Signature

```ts
function useConvexMutation<Mutation>(
  mutation: Mutation,
  options?: UseConvexMutationOptions<Mutation>
): UseConvexMutationReturn<Mutation>
```

## Parameters

### mutation

The Convex mutation function reference from your generated API.

```ts
import { api } from '~~/convex/_generated/api'

const { mutate } = useConvexMutation(api.posts.create)
```

### options

| Option | Type | Description |
|--------|------|-------------|
| `optimisticUpdate` | `(localStore, args) => void` | Update local cache immediately |

```ts
const { mutate } = useConvexMutation(api.posts.create, {
  optimisticUpdate: (localStore, args) => {
    // Update queries before server responds
  },
})
```

## Return Value

| Property | Type | Description |
|----------|------|-------------|
| `mutate` | `(args) => Promise<Result>` | Execute the mutation |
| `data` | `Ref<Result \| undefined>` | Last mutation result |
| `status` | `ComputedRef<MutationStatus>` | Current status |
| `pending` | `ComputedRef<boolean>` | True while mutation is running |
| `error` | `Ref<Error \| null>` | Error if mutation failed |
| `reset` | `() => void` | Clear data and error |

### status

| Value | Meaning |
|-------|---------|
| `'idle'` | No mutation in progress |
| `'pending'` | Mutation running |
| `'success'` | Mutation completed |
| `'error'` | Mutation failed |

## Usage Examples

### Basic Mutation

```ts
const { mutate, pending, error } = useConvexMutation(api.posts.create)

async function handleSubmit() {
  try {
    const id = await mutate({ title: 'Hello', content: 'World' })
    console.log('Created post:', id)
  } catch (err) {
    console.error('Failed:', err)
  }
}
```

### With Status Tracking

```vue
<script setup lang="ts">
const { mutate, pending, error, reset } = useConvexMutation(api.posts.create)
</script>

<template>
  <form @submit.prevent="mutate({ title, content })">
    <button :disabled="pending">
      {{ pending ? 'Saving...' : 'Save' }}
    </button>
  </form>

  <div v-if="error">
    {{ error.message }}
    <button @click="reset">Dismiss</button>
  </div>
</template>
```

### Optimistic Update

Update the UI immediately, before the server responds:

```ts
const { mutate } = useConvexMutation(api.todos.create, {
  optimisticUpdate: (localStore, args) => {
    updateQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      updater: (current) => {
        const optimistic = {
          _id: crypto.randomUUID() as Id<'todos'>,
          _creationTime: Date.now(),
          text: args.text,
          completed: false,
        }
        return current ? [optimistic, ...current] : [optimistic]
      },
    })
  },
})
```

### Multiple Mutations

Each call is tracked independently:

```ts
const { mutate: createPost, pending: creating } = useConvexMutation(api.posts.create)
const { mutate: deletePost, pending: deleting } = useConvexMutation(api.posts.delete)

// Can track each operation's status separately
```

## Optimistic Update Helpers

Import these helpers for common update patterns:

### updateQuery

Modify a query result using an updater function:

```ts
import { updateQuery } from '#imports'

updateQuery({
  query: api.todos.list,
  args: {},
  localQueryStore: localStore,
  updater: (current) => current ? [newItem, ...current] : [newItem],
})
```

### setQueryData

Replace a query result directly:

```ts
import { setQueryData } from '#imports'

setQueryData({
  query: api.user.get,
  args: { id: userId },
  localQueryStore: localStore,
  value: { ...existingUser, name: newName },
})
```

### deleteFromQuery

Remove items from an array query:

```ts
import { deleteFromQuery } from '#imports'

deleteFromQuery({
  query: api.todos.list,
  args: {},
  localQueryStore: localStore,
  shouldDelete: (todo) => todo._id === deletedId,
})
```

### updateAllQueries

Update all instances of a query (any args):

```ts
import { updateAllQueries } from '#imports'

updateAllQueries({
  query: api.user.get,
  localQueryStore: localStore,
  updater: (user) => user?._id === userId ? { ...user, name: newName } : user,
})
```

## Paginated Query Helpers

For paginated queries, use these specialized helpers:

### insertAtTop

Add item to the beginning:

```ts
import { insertAtTop } from '#imports'

insertAtTop({
  paginatedQuery: api.messages.list,
  localQueryStore: localStore,
  item: newMessage,
})
```

### deleteFromPaginatedQuery

Remove item from paginated results:

```ts
import { deleteFromPaginatedQuery } from '#imports'

deleteFromPaginatedQuery({
  paginatedQuery: api.messages.list,
  localQueryStore: localStore,
  shouldDelete: (msg) => msg._id === deletedId,
})
```

### optimisticallyUpdateValueInPaginatedQuery

Update items in place:

```ts
import { optimisticallyUpdateValueInPaginatedQuery } from '#imports'

optimisticallyUpdateValueInPaginatedQuery({
  paginatedQuery: api.tasks.list,
  localQueryStore: localStore,
  updateValue: (task) =>
    task._id === taskId ? { ...task, completed: true } : task,
})
```

## Error Handling

Errors are available in two ways:

```ts
const { mutate, error } = useConvexMutation(api.posts.create)

// Way 1: Check error ref
async function handleSubmit() {
  await mutate({ title: 'Test' })
  if (error.value) {
    console.error('Failed:', error.value.message)
  }
}

// Way 2: Try-catch
async function handleSubmit() {
  try {
    await mutate({ title: 'Test' })
  } catch (err) {
    console.error('Failed:', err)
  }
}
```

## TypeScript

Fully typed based on your Convex mutation definitions:

```ts
// If api.posts.create has args { title: string, content: string }
// and returns Id<'posts'>

const { mutate, data } = useConvexMutation(api.posts.create)

await mutate({ title: 'Hello', content: 'World' }) // ✓
await mutate({ title: 'Hello' }) // ✗ Type error: missing 'content'

// data is Ref<Id<'posts'> | undefined>
```

## Notes

- Mutations don't automatically retry on failure
- Optimistic updates roll back automatically if the mutation fails
- The `pending` state tracks the current mutation only (not queued ones)
- Calling `mutate` while another is pending doesn't queue them — both run
