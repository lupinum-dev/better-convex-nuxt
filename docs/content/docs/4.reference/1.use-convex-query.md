---
title: useConvexQuery
description: Fetch data with SSR support and real-time updates.
navigation:
  icon: i-lucide-search
---

Subscribe to a Convex query with automatic real-time updates and optional server-side rendering.

## Signature

```ts
function useConvexQuery<Query, DataT = FunctionReturnType<Query>>(
  query: Query,
  args?: FunctionArgs<Query> | Ref<FunctionArgs<Query>> | ComputedRef<FunctionArgs<Query>> | 'skip',
  options?: UseConvexQueryOptions<DataT>
): Promise<UseConvexQueryReturn<DataT>>
```

## Parameters

### query

The Convex query function reference from your generated API.

```ts
import { api } from '~~/convex/_generated/api'

const { data } = await useConvexQuery(api.posts.list, {})
```

### args

Arguments to pass to the query. Can be:

| Type | Description |
|------|-------------|
| `object` | Static arguments |
| `Ref<object>` | Reactive arguments (re-fetches on change) |
| `ComputedRef<object>` | Computed arguments |
| `'skip'` | Skip the query entirely |

```ts
// Static args
const { data } = await useConvexQuery(api.posts.get, { id: '123' })

// Reactive args
const id = ref('123')
const { data } = await useConvexQuery(api.posts.get, computed(() => ({ id: id.value })))

// Skip when condition is false
const { data } = await useConvexQuery(
  api.posts.get,
  computed(() => selectedId.value ? { id: selectedId.value } : 'skip')
)
```

### options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `server` | `boolean` | `false` | Run query on server during SSR |
| `lazy` | `boolean` | `false` | Don't block navigation, show loading state |
| `subscribe` | `boolean` | `true` | Subscribe to real-time updates via WebSocket |
| `default` | `() => DataT` | `undefined` | Factory function for initial value |
| `transform` | `(raw) => DataT` | `undefined` | Transform data after fetch |
| `public` | `boolean` | `false` | Skip auth token attachment |

```ts
const { data } = await useConvexQuery(
  api.posts.list,
  {},
  {
    server: true,           // SSR
    lazy: true,             // Don't block navigation
    default: () => [],      // Initial value
    transform: (posts) =>   // Transform results
      posts.map(p => ({ ...p, date: new Date(p.createdAt) })),
  }
)
```

## Return Value

The composable returns a Promise that resolves to an object with these properties:

| Property | Type | Description |
|----------|------|-------------|
| `data` | `Ref<DataT \| null>` | The query result |
| `status` | `ComputedRef<QueryStatus>` | Current status |
| `pending` | `ComputedRef<boolean>` | True if loading initial data |
| `error` | `Ref<Error \| null>` | Error if query failed |
| `refresh` | `() => Promise<void>` | Manually re-run the query |
| `execute` | `() => Promise<void>` | Alias for refresh |
| `clear` | `() => void` | Clear data and error |

### status

| Value | Meaning |
|-------|---------|
| `'idle'` | Query is skipped (args = `'skip'`) |
| `'pending'` | Waiting for initial data |
| `'success'` | Data loaded successfully |
| `'error'` | Query failed |

## Usage Examples

### Basic Query

```ts
const { data: posts, status } = await useConvexQuery(api.posts.list, {})
```

### SSR with Lazy Loading

Best for SEO pages with instant client navigation:

```ts
const { data, pending } = await useConvexQuery(
  api.posts.list,
  {},
  { server: true, lazy: true }
)
```

### Reactive Arguments

Query re-runs when arguments change:

```ts
const category = ref('tech')

const { data } = await useConvexQuery(
  api.posts.byCategory,
  computed(() => ({ category: category.value }))
)

// Later: changing category triggers new query
category.value = 'design'
```

### Conditional Query

Skip query based on conditions:

```ts
const { isAuthenticated } = useConvexAuth()

const { data } = await useConvexQuery(
  api.user.profile,
  computed(() => isAuthenticated.value ? {} : 'skip')
)
```

### Transform Data

Process data before it reaches your component:

```ts
const { data: posts } = await useConvexQuery(
  api.posts.list,
  {},
  {
    transform: (raw) => raw.map(post => ({
      ...post,
      createdAt: new Date(post._creationTime),
      excerpt: post.content.slice(0, 200),
    })),
  }
)
```

### Without Subscription

Fetch once without real-time updates:

```ts
const { data, refresh } = await useConvexQuery(
  api.stats.overview,
  {},
  { subscribe: false }
)

// Manually refresh when needed
async function handleRefresh() {
  await refresh()
}
```

### With Default Value

Provide initial data while loading:

```ts
const { data } = await useConvexQuery(
  api.posts.list,
  {},
  { default: () => [] }
)

// data.value is [] instead of null while loading
```

### Public Query (No Auth)

Skip auth token for public endpoints:

```ts
const { data } = await useConvexQuery(
  api.public.featured,
  {},
  { public: true }
)
```

## TypeScript

The composable is fully typed. Return type is inferred from your Convex query:

```ts
// If api.posts.list returns Post[]
const { data } = await useConvexQuery(api.posts.list, {})
// data is Ref<Post[] | null>

// With transform
const { data } = await useConvexQuery(
  api.posts.list,
  {},
  { transform: (posts): ProcessedPost[] => /* ... */ }
)
// data is Ref<ProcessedPost[] | null>
```

## Notes

- The `await` respects `lazy` option â€” with `lazy: true`, it resolves immediately
- Subscriptions are automatically cleaned up when the component unmounts
- Multiple components with the same query + args share one subscription
- Changes to reactive args trigger new subscriptions (old ones are cleaned up)
