---
title: useConvexPaginatedQuery
description: Paginated queries with load more and infinite scroll.
navigation:
  icon: i-lucide-layers
---

Subscribe to a paginated Convex query with automatic page management and real-time updates.

## Signature

```ts
function useConvexPaginatedQuery<Query, TransformedItem = Item>(
  query: Query,
  args?: Omit<FunctionArgs<Query>, 'paginationOpts'>,
  options: UseConvexPaginatedQueryOptions<TransformedItem>
): Promise<UseConvexPaginatedQueryReturn<TransformedItem>>
```

## Parameters

### query

A Convex query that accepts `paginationOpts` and returns paginated results.

```ts
// Your query must use paginationOptsValidator
const { results } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 10 }
)
```

### args

Arguments to pass to the query, excluding `paginationOpts` (handled automatically).

```ts
const { results } = await useConvexPaginatedQuery(
  api.posts.byCategory,
  { category: 'tech' },
  { initialNumItems: 10 }
)
```

### options (required)

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `initialNumItems` | `number` | Yes | Items to load on first page |
| `server` | `boolean` | No | SSR for first page |
| `lazy` | `boolean` | No | Don't block navigation |
| `subscribe` | `boolean` | No | Real-time updates (default: true) |
| `public` | `boolean` | No | Skip auth token |
| `default` | `() => Item[]` | No | Initial value factory |
| `transform` | `(items) => TransformedItem[]` | No | Transform results |

```ts
const { results } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  {
    initialNumItems: 20,
    server: true,
    lazy: true,
    transform: (posts) => posts.map(p => ({ ...p, date: new Date(p.createdAt) })),
  }
)
```

## Return Value

| Property | Type | Description |
|----------|------|-------------|
| `results` | `ComputedRef<Item[]>` | All loaded items (concatenated) |
| `status` | `ComputedRef<PaginationStatus>` | Current pagination state |
| `isLoading` | `ComputedRef<boolean>` | True if loading any page |
| `loadMore` | `(numItems: number) => void` | Load next page |
| `refresh` | `() => Promise<void>` | Re-fetch all pages |
| `reset` | `() => Promise<void>` | Clear and restart |
| `clear` | `() => void` | Clear without re-fetch |
| `error` | `Ref<Error \| null>` | Error if query failed |

### status

| Value | Meaning |
|-------|---------|
| `'LoadingFirstPage'` | Loading initial data |
| `'CanLoadMore'` | More data available |
| `'LoadingMore'` | Fetching next page |
| `'Exhausted'` | All data loaded |

## Backend Setup

Your Convex query must accept pagination options:

```ts [convex/posts.ts]
import { query } from './_generated/server'
import { paginationOptsValidator } from 'convex/server'

export const list = query({
  args: {
    paginationOpts: paginationOptsValidator,
    category: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    let q = ctx.db.query('posts').order('desc')

    if (args.category) {
      q = q.filter(q => q.eq(q.field('category'), args.category))
    }

    return q.paginate(args.paginationOpts)
  },
})
```

## Usage Examples

### Basic Pagination

```vue
<script setup lang="ts">
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 10 }
)
</script>

<template>
  <div>
    <PostCard v-for="post in results" :key="post._id" :post="post" />

    <button v-if="status === 'CanLoadMore'" @click="loadMore(10)">
      Load More
    </button>

    <p v-if="status === 'LoadingMore'">Loading...</p>
    <p v-if="status === 'Exhausted'">No more posts</p>
  </div>
</template>
```

### Infinite Scroll

```vue
<script setup lang="ts">
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 20 }
)

const loadTrigger = ref<HTMLElement>()

useIntersectionObserver(loadTrigger, ([entry]) => {
  if (entry.isIntersecting && status.value === 'CanLoadMore') {
    loadMore(20)
  }
})
</script>

<template>
  <div>
    <PostCard v-for="post in results" :key="post._id" :post="post" />
    <div ref="loadTrigger" class="h-1" />
    <Spinner v-if="status === 'LoadingMore'" />
  </div>
</template>
```

### With Filters

```vue
<script setup lang="ts">
const category = ref('all')

const { results, status, loadMore, reset } = await useConvexPaginatedQuery(
  api.posts.list,
  computed(() => ({
    category: category.value === 'all' ? undefined : category.value,
  })),
  { initialNumItems: 10 }
)

// Reset when filter changes
watch(category, () => reset())
</script>

<template>
  <select v-model="category">
    <option value="all">All</option>
    <option value="tech">Tech</option>
    <option value="design">Design</option>
  </select>

  <PostCard v-for="post in results" :key="post._id" :post="post" />

  <button v-if="status === 'CanLoadMore'" @click="loadMore(10)">
    More
  </button>
</template>
```

### With SSR

```ts
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  {
    initialNumItems: 20,
    server: true,  // First page SSR
  }
)
```

### Transform Results

```ts
const { results } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  {
    initialNumItems: 10,
    transform: (posts) => posts.map(post => ({
      ...post,
      formattedDate: formatDate(post._creationTime),
      readingTime: calculateReadingTime(post.content),
    })),
  }
)
```

## Status-Based UI

```vue
<template>
  <!-- Loading first page -->
  <div v-if="status === 'LoadingFirstPage'" class="grid">
    <SkeletonCard v-for="i in 10" :key="i" />
  </div>

  <!-- Has data -->
  <template v-else>
    <div class="grid">
      <PostCard v-for="post in results" :key="post._id" :post="post" />
    </div>

    <!-- Load more button -->
    <button
      v-if="status === 'CanLoadMore'"
      @click="loadMore(10)"
      class="btn"
    >
      Load More
    </button>

    <!-- Loading more indicator -->
    <Spinner v-if="status === 'LoadingMore'" />

    <!-- End of list -->
    <p v-if="status === 'Exhausted'" class="text-gray-500">
      You've reached the end
    </p>
  </template>
</template>
```

## Real-Time Updates

Paginated queries stay real-time. When data changes:

- New items appear at the top (if they match the sort order)
- Deleted items disappear
- Updated items reflect changes

Each page maintains its own subscription. Updates flow through without breaking pagination.

## Reset vs Refresh vs Clear

| Method | Effect |
|--------|--------|
| `reset()` | Clear all pages, restart from page 1 |
| `refresh()` | Re-fetch all loaded pages |
| `clear()` | Clear data without re-fetching |

Use `reset()` when filters change. Use `refresh()` for manual reload. Use `clear()` when navigating away.

## TypeScript

Fully typed based on your query definition:

```ts
// If api.posts.list returns { _id: Id<'posts'>, title: string }[]

const { results } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 10 }
)

// results is ComputedRef<{ _id: Id<'posts'>, title: string }[]>

// With transform
const { results } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  {
    initialNumItems: 10,
    transform: (posts): EnhancedPost[] => /* ... */,
  }
)

// results is ComputedRef<EnhancedPost[]>
```

## Notes

- First page can be SSR'd; subsequent pages are client-only
- Subscriptions per page are managed automatically
- Changing args triggers a reset
- The `results` array contains all loaded pages concatenated
