---
title: Mutations
description: Execute Convex mutations with loading state, error handling, and optimistic updates.
navigation:
  icon: i-lucide-pen-tool
---

Unlike queries, mutations are **action-focused**: you call `mutate()`, use the return value, and move on. There's no data to render in templates.

::callout{icon="i-lucide-lightbulb"}
**Tip**: Always extract `.value` from refs when calling `mutate()`. This makes the data flow explicit and avoids potential issues.
::

## Basic Usage

```vue
<script setup lang="ts">
import { api } from '~/convex/_generated/api'

const { mutate, pending, error } = useConvexMutation(api.todos.create)

const text = ref('')

async function handleSubmit() {
  try {
    // Extract .value from refs before passing to mutate
    const todo = await mutate({ text: text.value })
    console.log('Created:', todo._id)
    text.value = ''
    navigateTo('/todos')
  } catch {
    // error.value is already set for template display
  }
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <input v-model="text" :disabled="pending" />
    <button :disabled="pending">
      {{ pending ? 'Saving...' : 'Save' }}
    </button>
    <p v-if="error" class="error">{{ error.message }}</p>
  </form>
</template>
```

## API Reference

### Parameters

| Parameter  | Type                            | Description                        |
| ---------- | ------------------------------- | ---------------------------------- |
| `mutation` | `FunctionReference<"mutation">` | Convex mutation function reference |
| `options`  | `UseConvexMutationOptions`      | Optional configuration             |

### Options

| Option             | Type                         | Default | Description                                 |
| ------------------ | ---------------------------- | ------- | ------------------------------------------- |
| `optimisticUpdate` | `(localStore, args) => void` | -       | Update local queries before server confirms |

::callout{icon="i-lucide-info" to="/docs/advanced/logging"}
Enable module-level logging via the `logging` config option for debugging mutations.
::

### Returns

| Property  | Type                          | Description                                         |
| --------- | ----------------------------- | --------------------------------------------------- |
| `mutate`  | `(args) => Promise<Result>`   | Execute the mutation                                |
| `data`    | `Ref<Result \| undefined>`    | Result from last successful mutation                |
| `status`  | `ComputedRef<MutationStatus>` | `'idle'` \| `'pending'` \| `'success'` \| `'error'` |
| `pending` | `ComputedRef<boolean>`        | True while mutation is in flight                    |
| `error`   | `Ref<Error \| null>`          | Error from last attempt                             |
| `reset`   | `() => void`                  | Clear error and status                              |

## Key Behaviors

### Pending State

The `pending` ref is `true` while **any** mutation call is in flight. Handles concurrent mutations correctly:

```ts
const { mutate, pending } = useConvexMutation(api.tasks.create)

// Fire two mutations
mutate({ text: 'A' })
mutate({ text: 'B' })

// pending is true until BOTH complete
console.log(pending.value) // true
```

### Error Handling

Errors are captured in `error` ref AND re-thrown from `mutate()`:

```ts
const { mutate, error } = useConvexMutation(api.tasks.create)

try {
  await mutate({ text: '' })
} catch (e) {
  // Can handle here OR use error.value in template
  console.log(error.value === e) // true
}
```

The error is automatically cleared when you call `mutate()` again.

### Reset Function

Use `reset()` to clear error state:

```vue
<script setup>
const { mutate, error, reset } = useConvexMutation(api.tasks.create)

// Clear error when user starts typing
function handleInput() {
  if (error.value) reset()
}
</script>
```

---

## With Optimistic Updates

For instant UI feedback, provide an `optimisticUpdate` function:

```ts
const { mutate } = useConvexMutation(api.todos.create, {
  optimisticUpdate: (localStore, args) => {
    // Update the local query cache immediately
    updateQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      updater: (current) => {
        const optimisticTodo = {
          _id: crypto.randomUUID() as Id<'todos'>,
          _creationTime: Date.now(),
          text: args.text,
          completed: false,
        }
        return current ? [optimisticTodo, ...current] : [optimisticTodo]
      },
    })
  },
})
```

The optimistic update is automatically rolled back if the mutation fails.

::callout{icon="i-lucide-lightbulb" to="/docs/mutations/optimistic-updates"}
See [Optimistic Updates](/docs/mutations/optimistic-updates) for complete patterns and helper functions.
::

---

## Patterns

### Form Submission

```vue
<script setup lang="ts">
const text = ref('')
const { mutate, pending, error, reset } = useConvexMutation(api.todos.create)

async function handleSubmit() {
  try {
    await mutate({ text: text.value })
    text.value = ''
    navigateTo('/todos')
  } catch {
    // Error shown in template
  }
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <input
      v-model="text"
      :disabled="pending"
      @input="reset"
    />
    <button :disabled="pending || !text.trim()">
      {{ pending ? 'Creating...' : 'Create Todo' }}
    </button>
    <p v-if="error" class="text-red-500">{{ error.message }}</p>
  </form>
</template>
```

### Multiple Independent Mutations

Each `useConvexMutation` call has independent state:

```vue
<script setup lang="ts">
const {
  mutate: createTodo,
  pending: isCreating,
  error: createError,
} = useConvexMutation(api.todos.create)

const {
  mutate: deleteTodo,
  pending: isDeleting,
  error: deleteError,
} = useConvexMutation(api.todos.remove)
</script>

<template>
  <button :disabled="isCreating">Create</button>
  <button :disabled="isDeleting">Delete</button>
</template>
```

### Per-Item Loading States

Track loading state per item using a Map:

```vue
<script setup lang="ts">
const { mutate: toggleTodo } = useConvexMutation(api.todos.toggle)
const loadingItems = ref(new Map<string, boolean>())

async function handleToggle(id: string) {
  loadingItems.value.set(id, true)
  try {
    await toggleTodo({ id })
  } finally {
    loadingItems.value.delete(id)
  }
}
</script>

<template>
  <ul>
    <li v-for="todo in todos" :key="todo._id">
      <input
        type="checkbox"
        :checked="todo.completed"
        :disabled="loadingItems.get(todo._id)"
        @change="handleToggle(todo._id)"
      />
      {{ todo.text }}
    </li>
  </ul>
</template>
```

### Status-Based UI

```vue
<script setup lang="ts">
const { mutate, status, error, reset } = useConvexMutation(api.todos.create)
</script>

<template>
  <div>
    <button @click="mutate({ text: 'New todo' })">
      <span v-if="status === 'idle'">Create</span>
      <span v-else-if="status === 'pending'">Creating...</span>
      <span v-else-if="status === 'success'">Created!</span>
      <span v-else-if="status === 'error'">Failed</span>
    </button>

    <p v-if="status === 'error'">
      {{ error?.message }}
      <button @click="reset">Dismiss</button>
    </p>
  </div>
</template>
```

---

## Comparison with useConvexQuery

| Aspect             | useConvexQuery             | useConvexMutation              |
| ------------------ | -------------------------- | ------------------------------ |
| **Purpose**        | Fetch data to display      | Execute actions                |
| **Data**           | Returns reactive `data`    | Returns result from `mutate()` |
| **Real-time**      | Auto-updates via WebSocket | N/A                            |
| **SSR**            | Yes                        | N/A (client-only)              |
| **Template usage** | Render `data.value`        | Show `pending`/`error`         |

---

## TypeScript

Full type inference from your Convex schema:

```ts
// Args are typed based on your mutation definition
const { mutate } = useConvexMutation(api.todos.create)

// Type error: 'title' doesn't exist, should be 'text'
await mutate({ title: 'wrong' })

// Correct: matches your schema
await mutate({ text: 'correct' })

// Return type is inferred
const todo = await mutate({ text: 'Hello' })
console.log(todo._id) // typed as Id<"todos">
```

---

## Common Mistakes

### 1. Not handling errors

```ts
// WRONG: Unhandled promise rejection
async function handleClick() {
  await mutate({ text: 'Hello' })
  // If mutation fails, this crashes
}

// RIGHT: Handle the error
async function handleClick() {
  try {
    await mutate({ text: 'Hello' })
  } catch {
    // Error is in error.value for display
  }
}
```

### 2. Forgetting to clear form on success

```ts
// WRONG: Form stays filled after success
async function handleSubmit() {
  await mutate({ text: text.value })
  navigateTo('/list')
}

// RIGHT: Clear form state
async function handleSubmit() {
  await mutate({ text: text.value })
  text.value = '' // Clear before navigation
  navigateTo('/list')
}
```

### 3. Using shared pending for independent actions

```vue
<!-- WRONG: Single pending blocks all buttons -->
<script setup>
const { mutate, pending } = useConvexMutation(api.items.delete)
</script>
<template>
  <button
    v-for="item in items"
    :disabled="pending"
    @click="mutate({ id: item._id })"
  >
    Delete
  </button>
</template>

<!-- RIGHT: Track per-item loading -->
<script setup>
const { mutate } = useConvexMutation(api.items.delete)
const deleting = ref(new Set())

async function handleDelete(id) {
  deleting.value.add(id)
  try {
    await mutate({ id })
  } finally {
    deleting.value.delete(id)
  }
}
</script>
<template>
  <button
    v-for="item in items"
    :disabled="deleting.has(item._id)"
    @click="handleDelete(item._id)"
  >
    Delete
  </button>
</template>
```

---

## Related Topics

- [Actions](/docs/mutations/actions) - For external API calls and side effects
- [Optimistic Updates](/docs/mutations/optimistic-updates) - Instant UI feedback
