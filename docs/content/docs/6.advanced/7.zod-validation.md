---
title: Schema Validation
description: Share validation schemas between client and server using Zod, Valibot, or any Standard Schema library.
navigation:
  icon: i-lucide-shield-check
---

Define validation rules once and use them everywhere: client-side forms, Convex mutations, and TypeScript types—all from a single source of truth.

::callout{icon="i-lucide-info" to="https://github.com/standard-schema/standard-schema" target="\_blank"}
This module supports any [Standard Schema](https://github.com/standard-schema/standard-schema) library: **Zod**, **Valibot**, **ArkType**, **Effect Schema**, and more.
::

---

## Overview

| Feature | Import | Description |
|---------|--------|-------------|
| `zCustomMutation` | `better-convex-nuxt/zod` | Define Convex mutations with Zod schemas |
| `zCustomQuery` | `better-convex-nuxt/zod` | Define Convex queries with Zod schemas |
| `zCustomAction` | `better-convex-nuxt/zod` | Define Convex actions with Zod schemas |
| `useFormValidation` | Auto-imported | Client-side form validation (any Standard Schema library) |

---

## Quick Start

### 1. Define a Shared Schema

Create your validation schema in a shared location:

```ts [shared/schemas/task.ts]
import { z } from 'zod'

export const createTaskSchema = z.object({
  title: z.string()
    .min(3, 'Title must be at least 3 characters')
    .max(100, 'Title must be less than 100 characters'),
  priority: z.enum(['low', 'medium', 'high']),
})

// Export the TypeScript type for use in components
export type CreateTaskInput = z.infer<typeof createTaskSchema>
```

### 2. Use in Convex Mutation

Use `zCustomMutation` to define mutations with Zod schemas as the argument definition:

```ts [convex/tasks.ts]
import { mutation } from './_generated/server'
import { zCustomMutation, NoOp } from 'better-convex-nuxt/zod'
import { createTaskSchema } from '../shared/schemas/task'

// Create a Zod-enabled mutation builder
const zMutation = zCustomMutation(mutation, NoOp)

export const create = zMutation({
  // Zod schema IS the args definition
  args: createTaskSchema,
  handler: async (ctx, args) => {
    // args is fully typed from Zod schema
    // Dashboard shows proper argument types
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) throw new Error('Not authenticated')

    return ctx.db.insert('tasks', {
      userId: identity.subject,
      title: args.title,     // Typed as string
      priority: args.priority, // Typed as 'low' | 'medium' | 'high'
      completed: false,
    })
  },
})
```

### 3. Validate on Client

Use `useFormValidation` for reactive client-side validation:

```vue [pages/tasks/new.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'
import { createTaskSchema, type CreateTaskInput } from '~/shared/schemas/task'

const { mutate, pending, error } = useConvexMutation(api.tasks.create)
const { errors, isValid, validate, getError } = useFormValidation(createTaskSchema)

const form = reactive<CreateTaskInput>({
  title: '',
  priority: 'medium',
})

async function handleSubmit() {
  // Validate on client first
  const validated = await validate(form)
  if (!validated) return

  // Send to Convex (validated again on server)
  await mutate(validated)
  navigateTo('/tasks')
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <div>
      <input v-model="form.title" placeholder="Task title" :disabled="pending" />
      <span v-if="getError('title')" class="error">{{ getError('title') }}</span>
    </div>

    <div>
      <select v-model="form.priority" :disabled="pending">
        <option value="low">Low</option>
        <option value="medium">Medium</option>
        <option value="high">High</option>
      </select>
      <span v-if="getError('priority')" class="error">{{ getError('priority') }}</span>
    </div>

    <!-- Server errors -->
    <p v-if="error" class="error">{{ error.message }}</p>

    <button :disabled="pending || !isValid">
      {{ pending ? 'Creating...' : 'Create Task' }}
    </button>
  </form>
</template>
```

---

## Server-Side Validation

### zCustomMutation

Create mutations that validate arguments with Zod:

```ts [convex/tasks.ts]
import { mutation } from './_generated/server'
import { zCustomMutation, NoOp, zid } from 'better-convex-nuxt/zod'
import { z } from 'zod'

const zMutation = zCustomMutation(mutation, NoOp)

export const create = zMutation({
  args: {
    title: z.string().min(3).max(100),
    priority: z.enum(['low', 'medium', 'high']).default('medium'),
    tags: z.array(z.string()).optional(),
  },
  handler: async (ctx, args) => {
    // args.title is string
    // args.priority is 'low' | 'medium' | 'high' (default applied)
    // args.tags is string[] | undefined
    return ctx.db.insert('tasks', args)
  },
})

export const update = zMutation({
  args: {
    id: zid('tasks'),  // Validates Convex ID for 'tasks' table
    title: z.string().min(3).optional(),
    completed: z.boolean().optional(),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args
    await ctx.db.patch(id, updates)
  },
})
```

### zCustomQuery

Create queries with Zod validation:

```ts [convex/tasks.ts]
import { query } from './_generated/server'
import { zCustomQuery, NoOp, zid } from 'better-convex-nuxt/zod'
import { z } from 'zod'

const zQuery = zCustomQuery(query, NoOp)

export const get = zQuery({
  args: { id: zid('tasks') },
  handler: async (ctx, args) => {
    return ctx.db.get(args.id)
  },
})

export const list = zQuery({
  args: {
    status: z.enum(['all', 'active', 'completed']).default('all'),
    limit: z.number().int().min(1).max(100).default(50),
  },
  handler: async (ctx, args) => {
    let query = ctx.db.query('tasks')

    if (args.status !== 'all') {
      query = query.filter(q =>
        q.eq(q.field('completed'), args.status === 'completed')
      )
    }

    return query.take(args.limit)
  },
})
```

### zCustomAction

Create actions with Zod validation:

```ts [convex/actions.ts]
import { action } from './_generated/server'
import { zCustomAction, NoOp } from 'better-convex-nuxt/zod'
import { z } from 'zod'

const zAction = zCustomAction(action, NoOp)

export const sendEmail = zAction({
  args: {
    to: z.string().email(),
    subject: z.string().min(1).max(200),
    body: z.string().min(1),
  },
  handler: async (ctx, args) => {
    // Call external email service
    await fetch('https://api.email.com/send', {
      method: 'POST',
      body: JSON.stringify(args),
    })
  },
})
```

### Convex ID Validation with zid

Use `zid` to validate Convex document IDs:

```ts
import { zid } from 'better-convex-nuxt/zod'

const args = {
  taskId: zid('tasks'),      // Validates ID is for 'tasks' table
  userId: zid('users'),      // Validates ID is for 'users' table
  parentId: zid('tasks').optional(),  // Optional ID
}
```

---

## Client-Side Validation

### useFormValidation

A composable for reactive form validation that works with any Standard Schema library.

#### Return Value

```ts
const {
  errors,         // Record<string, { message: string }> - Field errors
  isValid,        // ComputedRef<boolean> - No errors present
  isDirty,        // Ref<boolean> - Validation has run at least once
  validate,       // (data) => Promise<T | null> - Validate entire form
  validateField,  // (field, value, fullData) => Promise<boolean>
  clearErrors,    // () => void - Clear all errors
  clearFieldError,// (field: string) => void - Clear specific field
  hasError,       // (field: string) => boolean
  getError,       // (field: string) => string | undefined
} = useFormValidation(schema)
```

#### Basic Usage

```vue
<script setup lang="ts">
import { z } from 'zod'

const schema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

const { errors, validate, getError, isValid } = useFormValidation(schema)

const form = reactive({ email: '', password: '' })

async function handleSubmit() {
  const validated = await validate(form)
  if (!validated) return

  // validated is typed as { email: string; password: string }
  await submitToServer(validated)
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <input v-model="form.email" type="email" />
    <span v-if="getError('email')">{{ getError('email') }}</span>

    <input v-model="form.password" type="password" />
    <span v-if="getError('password')">{{ getError('password') }}</span>

    <button :disabled="!isValid">Submit</button>
  </form>
</template>
```

#### Field-Level Validation

Validate individual fields on blur:

```vue
<script setup lang="ts">
const { validateField, getError, clearFieldError } = useFormValidation(schema)

const form = reactive({ email: '', password: '' })

async function handleBlur(field: keyof typeof form) {
  await validateField(field, form[field], form)
}

function handleInput(field: keyof typeof form) {
  // Clear error as user types
  clearFieldError(field)
}
</script>

<template>
  <input
    v-model="form.email"
    @blur="handleBlur('email')"
    @input="handleInput('email')"
  />
  <span v-if="getError('email')">{{ getError('email') }}</span>
</template>
```

---

## Using with Valibot

`useFormValidation` works with any Standard Schema library:

```vue
<script setup lang="ts">
import * as v from 'valibot'

const schema = v.object({
  email: v.pipe(v.string(), v.email('Invalid email')),
  age: v.pipe(v.number(), v.minValue(18, 'Must be 18 or older')),
})

type FormData = v.InferOutput<typeof schema>

const { validate, getError } = useFormValidation(schema)
const form = reactive<FormData>({ email: '', age: 0 })
</script>
```

---

## Converting Between Schemas

### Zod to Convex

Convert Zod schemas to Convex validators:

```ts
import { zodToConvex } from 'better-convex-nuxt/zod'
import { z } from 'zod'

const zodSchema = z.object({
  name: z.string(),
  age: z.number().int().positive(),
  tags: z.array(z.string()),
})

// Convert to Convex validator
const convexValidator = zodToConvex(zodSchema)
// Result: v.object({ name: v.string(), age: v.number(), tags: v.array(v.string()) })
```

### Convex to Zod

Convert Convex validators to Zod schemas:

```ts
import { convexToZod } from 'better-convex-nuxt/zod'
import { v } from 'convex/values'

const convexValidator = v.object({
  name: v.string(),
  active: v.boolean(),
})

// Convert to Zod schema
const zodSchema = convexToZod(convexValidator)
```

### Convex to Standard Schema

Convert Convex validators to Standard Schema format:

```ts
import { toStandardSchema } from 'better-convex-nuxt/zod'
import { v } from 'convex/values'

const convexValidator = v.object({
  name: v.string(),
  count: v.number(),
})

// Can now be used with useFormValidation
const standardSchema = toStandardSchema(convexValidator)
const { validate } = useFormValidation(standardSchema)
```

---

## Common Patterns

### Shared Schema Pattern

```
project/
├── shared/
│   └── schemas/
│       ├── task.ts
│       ├── user.ts
│       └── index.ts      # Re-export all schemas
├── convex/
│   └── tasks.ts          # Imports from ../shared/schemas
└── pages/
    └── tasks/
        └── new.vue       # Imports from ~/shared/schemas
```

```ts [shared/schemas/index.ts]
export * from './task'
export * from './user'
```

### Create and Update Schemas

```ts [shared/schemas/task.ts]
import { z } from 'zod'

// Base fields shared between create and update
const taskFields = {
  title: z.string().min(3).max(100),
  priority: z.enum(['low', 'medium', 'high']),
  description: z.string().max(1000).optional(),
}

// Create: all required fields
export const createTaskSchema = z.object(taskFields)

// Update: all optional (partial)
export const updateTaskSchema = z.object(taskFields).partial()

export type CreateTaskInput = z.infer<typeof createTaskSchema>
export type UpdateTaskInput = z.infer<typeof updateTaskSchema>
```

### Nested Object Validation

```ts [shared/schemas/post.ts]
import { z } from 'zod'

export const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().min(10, 'Content must be at least 10 characters'),
  metadata: z.object({
    tags: z.array(z.string()).min(1, 'At least one tag required'),
    category: z.enum(['tech', 'lifestyle', 'news']),
    publishAt: z.string().datetime().optional(),
  }),
})
```

### Cross-Field Validation

```ts [shared/schemas/booking.ts]
import { z } from 'zod'

export const createBookingSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  guests: z.number().int().positive().max(10),
}).refine(
  data => new Date(data.endDate) > new Date(data.startDate),
  {
    message: 'End date must be after start date',
    path: ['endDate'],
  }
)
```

### Transform and Coerce

```ts [shared/schemas/user.ts]
import { z } from 'zod'

export const createUserSchema = z.object({
  // Transform to lowercase
  email: z.string().email().transform(email => email.toLowerCase()),

  // Trim whitespace
  username: z.string().min(3).max(20).transform(s => s.trim()),

  // Coerce string to number (useful for form inputs)
  age: z.coerce.number().min(13, 'Must be at least 13 years old'),
})
```

---

## API Reference

### Exports from `better-convex-nuxt/zod`

| Export | Description |
|--------|-------------|
| `zCustomQuery` | Create queries with Zod argument validation |
| `zCustomMutation` | Create mutations with Zod argument validation |
| `zCustomAction` | Create actions with Zod argument validation |
| `NoOp` | Default customization (no modifications) |
| `zid` | Create Zod validator for Convex document IDs |
| `zodToConvex` | Convert Zod schema to Convex validator |
| `zodToConvexFields` | Convert Zod fields object to Convex validators |
| `convexToZod` | Convert Convex validator to Zod schema |
| `convexToZodFields` | Convert Convex fields to Zod schemas |
| `toStandardSchema` | Convert Convex validator to Standard Schema |
| `withSystemFields` | Add `_id` and `_creationTime` to Zod schema |

### useFormValidation

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `errors` | `Record<string, { message: string }>` | Reactive error object |
| `isValid` | `ComputedRef<boolean>` | True when no errors |
| `isDirty` | `Ref<boolean>` | True after first validation |
| `validate(data)` | `Promise<T \| null>` | Validate and return typed data or null |
| `validateField(field, value, fullData)` | `Promise<boolean>` | Validate single field |
| `clearErrors()` | `void` | Clear all errors |
| `clearFieldError(field)` | `void` | Clear specific field error |
| `hasError(field)` | `boolean` | Check if field has error |
| `getError(field)` | `string \| undefined` | Get error message |

---

## Best Practices

### 1. Always Validate on Both Sides

Client validation improves UX; server validation ensures security:

```ts
// Client: Fast feedback, prevents unnecessary requests
const validated = await validate(form)
if (!validated) return

// Server: Security layer via zCustomMutation
// Never trust client data - Zod runs again on server
```

### 2. Keep Schemas in Shared Location

Import the same schema in both Convex functions and Vue components.

### 3. Export Types Alongside Schemas

```ts
export const schema = z.object({ ... })
export type SchemaInput = z.infer<typeof schema>
```

### 4. Use Descriptive Error Messages

```ts
// Better
z.string().min(3, 'Task title must be at least 3 characters')

// Instead of default
z.string().min(3) // "String must contain at least 3 character(s)"
```

---

## Related

- [Mutations](/docs/mutations/mutations) - Using mutations with validated data
- [Error Handling](/docs/advanced/error-handling) - Handling validation errors in UI
- [convex-helpers Zod docs](https://github.com/get-convex/convex-helpers#zod-validation) - Full convex-helpers documentation
