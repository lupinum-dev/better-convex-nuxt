---
title: Zod Validation
description: Share validation schemas between client and server using Zod for type-safe forms and mutations.
navigation:
  icon: i-lucide-shield-check
---

Zod integration lets you define validation rules once and use them everywhere: client-side forms, Convex mutations, and TypeScript types—all from a single source of truth.

::callout{icon="i-lucide-lightbulb"}
**Why Zod?** Convex validators (`v.string()`, etc.) only run on the server. Zod schemas can validate on both client and server, giving you instant form feedback while maintaining server-side security.
::

## Quick Start

### 1. Define a Shared Schema

Create your validation schema in a shared location accessible by both client and server:

```ts [shared/schemas/task.schema.ts]
import { z } from 'zod'

export const createTaskSchema = z.object({
  title: z.string()
    .min(3, 'Title must be at least 3 characters')
    .max(100, 'Title must be less than 100 characters')
    .trim(),
  priority: z.enum(['low', 'medium', 'high']).default('medium'),
})

// Export the TypeScript type for use in components
export type CreateTaskInput = z.infer<typeof createTaskSchema>
```

### 2. Use in Convex Mutation

Import the helper and schema in your Convex function:

```ts [convex/tasks.ts]
import { v } from 'convex/values'
import { mutation } from './_generated/server'
import { validateZodInput } from 'better-convex-nuxt/zod'
import { createTaskSchema } from '../shared/schemas/task.schema'

export const create = mutation({
  args: { input: v.any() }, // Accept any, validate with Zod
  handler: async (ctx, args) => {
    // Single line validation with full type inference!
    const validated = validateZodInput(args.input, createTaskSchema)

    const identity = await ctx.auth.getUserIdentity()
    if (!identity) throw new Error('Not authenticated')

    return ctx.db.insert('tasks', {
      userId: identity.subject,
      title: validated.title,     // Typed as string
      priority: validated.priority, // Typed as 'low' | 'medium' | 'high'
      completed: false,
      createdAt: Date.now(),
    })
  },
})
```

### 3. Validate on Client

Use the same schema for client-side form validation:

```vue [pages/tasks/new.vue]
<script setup lang="ts">
import { api } from '~/convex/_generated/api'
import { createTaskSchema, type CreateTaskInput } from '~/shared/schemas/task.schema'

const client = useConvex()
const { mutate, pending, error } = useConvexMutation(api.tasks.create)

const form = reactive<CreateTaskInput>({
  title: '',
  priority: 'medium',
})
const validationErrors = ref<string[]>([])

async function handleSubmit() {
  // Clear previous errors
  validationErrors.value = []

  // Validate on client first
  const result = createTaskSchema.safeParse(form)

  if (!result.success) {
    validationErrors.value = result.error.issues.map(e => e.message)
    return // Don't send to server
  }

  // Send validated data to Convex
  try {
    await mutate({ input: result.data })
    navigateTo('/tasks')
  } catch {
    // Server error shown via error.value
  }
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <input
      v-model="form.title"
      placeholder="Task title"
      :disabled="pending"
    />

    <select v-model="form.priority" :disabled="pending">
      <option value="low">Low</option>
      <option value="medium">Medium</option>
      <option value="high">High</option>
    </select>

    <!-- Validation errors (client-side) -->
    <ul v-if="validationErrors.length" class="text-red-500">
      <li v-for="err in validationErrors" :key="err">{{ err }}</li>
    </ul>

    <!-- Server errors -->
    <p v-if="error" class="text-red-500">{{ error.message }}</p>

    <button :disabled="pending">
      {{ pending ? 'Creating...' : 'Create Task' }}
    </button>
  </form>
</template>
```

---

## API Reference

### validateZodInput

Validates input against a Zod schema in Convex functions. Throws a structured error if validation fails.

```ts
import { validateZodInput } from 'better-convex-nuxt/zod'

const validated = validateZodInput(input, schema, options?)
```

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `input` | `unknown` | The raw input to validate (typically `args.input`) |
| `schema` | `z.ZodTypeAny` | The Zod schema to validate against |
| `options` | `ValidateZodOptions` | Optional configuration |

#### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `errorPrefix` | `string` | `'Validation failed'` | Custom prefix for error messages |

#### Returns

The validated data with full TypeScript type inference based on your schema.

#### Throws

An `Error` with a structured `validationError` property containing:

```ts
interface ZodValidationError {
  code: 'VALIDATION_ERROR'
  message: string
  issues: Array<{
    path: PropertyKey[]
    message: string
    code: string
  }>
}
```

### isZodValidationError

Type guard to check if an error is a Zod validation error.

```ts
import { isZodValidationError } from 'better-convex-nuxt/zod'

try {
  const validated = validateZodInput(input, schema)
} catch (error) {
  if (isZodValidationError(error)) {
    // Access structured validation details
    console.log(error.validationError.issues)
  }
}
```

---

## Common Patterns

### Form with Field-Level Errors

Map Zod issues to specific form fields:

```vue
<script setup lang="ts">
import { createTaskSchema } from '~/shared/schemas/task.schema'

const form = reactive({ title: '', priority: 'medium' })
const fieldErrors = ref<Record<string, string>>({})

function validate() {
  fieldErrors.value = {}
  const result = createTaskSchema.safeParse(form)

  if (!result.success) {
    // Map errors to field names
    for (const issue of result.error.issues) {
      const field = issue.path[0] as string
      fieldErrors.value[field] = issue.message
    }
    return null
  }

  return result.data
}

async function handleSubmit() {
  const validated = validate()
  if (!validated) return

  await mutate({ input: validated })
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <div>
      <input v-model="form.title" placeholder="Title" />
      <span v-if="fieldErrors.title" class="text-red-500">
        {{ fieldErrors.title }}
      </span>
    </div>

    <div>
      <select v-model="form.priority">
        <option value="low">Low</option>
        <option value="medium">Medium</option>
        <option value="high">High</option>
      </select>
      <span v-if="fieldErrors.priority" class="text-red-500">
        {{ fieldErrors.priority }}
      </span>
    </div>

    <button type="submit">Create</button>
  </form>
</template>
```

### Nested Object Validation

```ts [shared/schemas/post.schema.ts]
import { z } from 'zod'

export const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().min(10, 'Content must be at least 10 characters'),
  metadata: z.object({
    tags: z.array(z.string()).min(1, 'At least one tag required'),
    category: z.enum(['tech', 'lifestyle', 'news']),
    publishAt: z.string().datetime().optional(),
  }),
})

export type CreatePostInput = z.infer<typeof createPostSchema>
```

### Optional Fields with Defaults

```ts [shared/schemas/settings.schema.ts]
import { z } from 'zod'

export const updateSettingsSchema = z.object({
  theme: z.enum(['light', 'dark', 'system']).default('system'),
  notifications: z.boolean().default(true),
  language: z.string().default('en'),
  // Optional without default - will be undefined if not provided
  bio: z.string().max(500).optional(),
})
```

### Transform and Preprocess

```ts [shared/schemas/user.schema.ts]
import { z } from 'zod'

export const createUserSchema = z.object({
  // Transform to lowercase
  email: z.string()
    .email('Invalid email')
    .transform(email => email.toLowerCase()),

  // Trim whitespace
  username: z.string()
    .min(3)
    .max(20)
    .regex(/^[a-zA-Z0-9_]+$/, 'Only letters, numbers, and underscores')
    .transform(s => s.trim()),

  // Coerce string to number
  age: z.coerce.number().min(13, 'Must be at least 13 years old'),
})
```

### Custom Error Messages

```ts [shared/schemas/order.schema.ts]
import { z } from 'zod'

export const createOrderSchema = z.object({
  quantity: z.number({
    required_error: 'Please enter a quantity',
    invalid_type_error: 'Quantity must be a number',
  })
    .int('Quantity must be a whole number')
    .positive('Quantity must be positive')
    .max(100, 'Maximum 100 items per order'),

  notes: z.string()
    .max(500, 'Notes cannot exceed 500 characters')
    .optional(),
})
```

### Refinements for Complex Validation

```ts [shared/schemas/booking.schema.ts]
import { z } from 'zod'

export const createBookingSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  guests: z.number().int().positive().max(10),
}).refine(
  data => new Date(data.endDate) > new Date(data.startDate),
  {
    message: 'End date must be after start date',
    path: ['endDate'], // Associate error with endDate field
  }
)
```

---

## Update Mutations

Apply the same pattern for update operations:

```ts [shared/schemas/task.schema.ts]
import { z } from 'zod'

// Create schema (all fields required)
export const createTaskSchema = z.object({
  title: z.string().min(3).max(100),
  priority: z.enum(['low', 'medium', 'high']),
})

// Update schema (all fields optional, but validated if present)
export const updateTaskSchema = z.object({
  title: z.string().min(3).max(100).optional(),
  priority: z.enum(['low', 'medium', 'high']).optional(),
  completed: z.boolean().optional(),
})

export type CreateTaskInput = z.infer<typeof createTaskSchema>
export type UpdateTaskInput = z.infer<typeof updateTaskSchema>
```

```ts [convex/tasks.ts]
import { validateZodInput } from 'better-convex-nuxt/zod'
import { updateTaskSchema } from '../shared/schemas/task.schema'

export const update = mutation({
  args: {
    id: v.id('tasks'),
    input: v.any(),
  },
  handler: async (ctx, args) => {
    const validated = validateZodInput(args.input, updateTaskSchema)

    // Only update fields that were provided
    await ctx.db.patch(args.id, validated)
  },
})
```

---

## Error Handling

### Server-Side Error Details

Access structured validation errors in your error handling:

```ts [convex/tasks.ts]
import { validateZodInput, isZodValidationError } from 'better-convex-nuxt/zod'

export const create = mutation({
  args: { input: v.any() },
  handler: async (ctx, args) => {
    try {
      const validated = validateZodInput(args.input, createTaskSchema)
      // ... create task
    } catch (error) {
      if (isZodValidationError(error)) {
        // Log detailed validation issues
        console.error('Validation issues:', error.validationError.issues)
      }
      throw error
    }
  },
})
```

### Client-Side Error Parsing

Parse validation errors from the server response:

```vue
<script setup lang="ts">
const { mutate, error } = useConvexMutation(api.tasks.create)

const validationMessage = computed(() => {
  if (!error.value) return null

  // Check if it's a validation error from the server
  if (error.value.message.startsWith('Validation failed:')) {
    return error.value.message.replace('Validation failed: ', '')
  }

  return error.value.message
})
</script>

<template>
  <p v-if="validationMessage" class="text-amber-500">
    {{ validationMessage }}
  </p>
</template>
```

---

## Best Practices

### 1. Always Validate on Both Sides

Client validation improves UX; server validation ensures security:

```ts
// Client: Fast feedback, prevents unnecessary requests
const result = schema.safeParse(input)
if (!result.success) {
  showErrors(result.error)
  return
}

// Server: Security layer, never trust client data
const validated = validateZodInput(args.input, schema)
```

### 2. Keep Schemas in a Shared Location

```
project/
├── shared/
│   └── schemas/
│       ├── task.schema.ts
│       ├── user.schema.ts
│       └── index.ts      # Re-export all schemas
├── convex/
│   └── tasks.ts          # Imports from ../shared/schemas
└── pages/
    └── tasks/
        └── new.vue       # Imports from ~/shared/schemas
```

### 3. Export Types Alongside Schemas

```ts [shared/schemas/task.schema.ts]
import { z } from 'zod'

export const createTaskSchema = z.object({
  title: z.string().min(3),
})

// Always export the inferred type
export type CreateTaskInput = z.infer<typeof createTaskSchema>
```

### 4. Use Descriptive Error Messages

```ts
// Instead of relying on defaults
z.string().min(3)
// "String must contain at least 3 character(s)"

// Provide context-specific messages
z.string().min(3, 'Task title must be at least 3 characters')
```

### 5. Validate Early, Fail Fast

```vue
<script setup lang="ts">
// Validate on blur for immediate feedback
function handleBlur(field: string) {
  const fieldSchema = createTaskSchema.shape[field]
  const result = fieldSchema.safeParse(form[field])

  if (!result.success) {
    fieldErrors.value[field] = result.error.issues[0].message
  } else {
    delete fieldErrors.value[field]
  }
}
</script>

<template>
  <input v-model="form.title" @blur="handleBlur('title')" />
</template>
```

---

## TypeScript Integration

Full type inference flows through your entire application:

```ts
// Schema definition
const schema = z.object({
  title: z.string(),
  count: z.number(),
})

// Inferred type: { title: string; count: number }
type Input = z.infer<typeof schema>

// In Convex function
const validated = validateZodInput(args.input, schema)
validated.title  // TypeScript knows this is string
validated.count  // TypeScript knows this is number

// In Vue component
const form = reactive<Input>({
  title: '',  // TypeScript enforces correct shape
  count: 0,
})
```

---

## Related Topics

- [Mutations](/docs/mutations/mutations) - Using validated data in mutations
- [Error Handling](/docs/advanced/error-handling) - Handling validation errors in UI
- [TypeScript](/docs/getting-started/concepts#typescript) - Type safety with Convex
