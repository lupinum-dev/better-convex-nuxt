---
title: Query Lifecycle
description: From request to render — what happens when you call useConvexQuery.
navigation:
  icon: i-lucide-git-branch
---

Every query goes through a series of steps. Understanding this lifecycle helps you debug issues and choose the right options.

## The Stages

```
1. Call          →  2. Options    →  3. Fetch      →  4. Subscribe   →  5. Update
   useConvexQuery      evaluated       data loaded      real-time        re-render
```

Let's trace through a typical query.

## Stage 1: Call

You call `useConvexQuery` in your component:

```ts
const { data, status } = await useConvexQuery(
  api.posts.list,
  { category: 'tech' },
  { server: true, lazy: false }
)
```

At this point:

- Query registered with the composable
- Options evaluated
- Reactive args wrapped if needed

## Stage 2: Options Evaluated

The module decides what to do based on options:

| Option | Effect |
|--------|--------|
| `server: true` | Run on server during SSR |
| `lazy: true` | Don't block navigation |
| `subscribe: false` | Skip WebSocket subscription |
| `default` | Initial value before data loads |
| `transform` | Process data after fetch |

The combination of `server`, `lazy`, and the current environment (SSR vs client) determines the loading behavior.

## Stage 3: Fetch

**During SSR (with `server: true`):**

```
Server receives request
       ↓
Reads auth token (if available)
       ↓
HTTP request to Convex
       ↓
Result embedded in HTML
       ↓
Status: 'success' immediately
```

**During client navigation (without lazy):**

```
Navigation triggered
       ↓
Query runs via WebSocket
       ↓
Navigation waits for result
       ↓
Page renders with data
```

**During client navigation (with lazy):**

```
Navigation triggered
       ↓
Page renders immediately (status: 'pending')
       ↓
Query runs in background
       ↓
Data arrives, component updates
```

## Stage 4: Subscribe

After initial data loads, the subscription phase:

```
Initial data received
       ↓
WebSocket subscription created
       ↓
Future updates pushed automatically
       ↓
data ref updates on each push
```

If `subscribe: false`, this stage is skipped. The data is static until you call `refresh()`.

## Stage 5: Update

When data changes (via subscription or refresh):

```
New data arrives
       ↓
Transform applied (if configured)
       ↓
data ref updated
       ↓
Vue reactivity triggers
       ↓
Component re-renders
```

The update is atomic. Your component sees the new state immediately.

## Status Transitions

```
Initial:    'pending' (or 'idle' if skipped)
                ↓
Data loads: 'success'
                ↓
Error:      'error' (if something fails)
                ↓
Skip:       'idle' (args = 'skip')
```

Key insight: Status can be `'success'` even while a background refresh is happening. Only the *initial* load shows `'pending'`.

## With Different Option Combinations

**Default (no options):**

```ts
const { data } = await useConvexQuery(api.posts.list, {})
```

- Client-only fetch
- Blocks navigation until data loads
- Subscribes to updates

**SSR + Lazy:**

```ts
const { data } = await useConvexQuery(api.posts.list, {}, {
  server: true,
  lazy: true,
})
```

- Server renders with data (direct visits)
- Client navigation is instant (shows pending, then data)
- Best of both worlds

**No subscription:**

```ts
const { data, refresh } = await useConvexQuery(api.posts.list, {}, {
  server: true,
  subscribe: false,
})
```

- One-time fetch
- No WebSocket connection for this query
- Call `refresh()` to update manually

## Argument Changes

When reactive args change:

```ts
const category = ref('tech')

const { data } = await useConvexQuery(
  api.posts.list,
  computed(() => ({ category: category.value }))
)

// Later:
category.value = 'design'  // What happens?
```

```
Args change detected
       ↓
Old subscription closed
       ↓
New fetch initiated
       ↓
status: 'pending' briefly
       ↓
New data arrives
       ↓
New subscription created
```

The transition is handled automatically. There's a brief pending state while new data loads.

## Error Handling

When something goes wrong:

```
Fetch fails (network, auth, server error)
       ↓
error ref populated
       ↓
status: 'error'
       ↓
data stays null (or previous value)
```

For subscription errors (after initial success):

```
Subscription update fails
       ↓
Error logged to console
       ↓
Subscription attempts recovery
       ↓
If recovers, error clears automatically
```

The module tries to be resilient. Temporary failures don't necessarily break your UI.

## Debugging the Lifecycle

Add `console.log` watchers to see what's happening:

```ts
const { data, status, error, pending } = await useConvexQuery(
  api.posts.list,
  {}
)

watchEffect(() => {
  console.log('Status:', status.value)
  console.log('Pending:', pending.value)
  console.log('Data:', data.value?.length, 'items')
  console.log('Error:', error.value?.message)
})
```

Or enable module logging:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  convex: {
    logging: { enabled: 'debug' },
  },
})
```

## Common Gotchas

**"Why is my data null on first render?"**

Check if you're using `server: true`. Without it, SSR renders with null data.

**"Why does my status never show 'pending'?"**

With `server: true`, data loads before render. You only see pending on client-side navigation (and only without lazy mode).

**"Why isn't my query updating?"**

Check `subscribe: false`. If set, you need to call `refresh()` manually.

**"Why do I see the query run twice?"**

Normal with SSR. Once on server, once on client (to set up subscription). The client uses the server-fetched data immediately while subscribing.
