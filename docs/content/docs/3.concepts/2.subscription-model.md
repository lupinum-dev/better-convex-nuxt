---
title: Subscription Model
description: How real-time updates flow from database to UI.
navigation:
  icon: i-lucide-radio
---

When you call `useConvexQuery`, you're not just fetching data — you're subscribing to it. The data stays in sync automatically. Here's how that works.

## The Flow

```
Database Change    →    Convex Server    →    WebSocket    →    Your Component
   (mutation)            (detects)           (pushes)          (re-renders)
```

1. Someone runs a mutation (could be you, could be another user)
2. Convex detects which queries are affected
3. Re-runs those queries
4. Pushes new results over WebSocket to all subscribed clients
5. Your component's data ref updates
6. Vue re-renders

You don't poll. You don't manually refresh. It just happens.

## What Gets Subscribed

Every `useConvexQuery` call creates a subscription (unless you set `subscribe: false`):

```ts
// Creates a subscription to api.todos.list with args {}
const { data } = await useConvexQuery(api.todos.list, {})
```

The subscription is identified by:

- The query function (`api.todos.list`)
- The arguments (`{}`)

Same query + same args = same subscription. Different args = different subscription.

## Subscription Deduplication

If multiple components subscribe to the same query:

```vue
<!-- ComponentA.vue -->
<script setup>
const { data } = await useConvexQuery(api.users.me, {})
</script>

<!-- ComponentB.vue -->
<script setup>
const { data } = await useConvexQuery(api.users.me, {})
</script>
```

Only one WebSocket subscription is created. Both components share it. When one unmounts, the other keeps receiving updates. When all unmount, the subscription closes.

This is automatic. You don't manage it.

## Reactive Arguments

When your query arguments change, the subscription updates:

```ts
const userId = ref('user-123')

// Subscription changes when userId changes
const { data } = await useConvexQuery(
  api.users.get,
  computed(() => ({ id: userId.value }))
)

// Later: changing userId automatically re-subscribes
userId.value = 'user-456'  // New subscription created
```

The old subscription closes. A new one opens for the new args. The transition is seamless.

## Skipping Subscriptions

Sometimes you want to conditionally skip a query:

```ts
const selectedId = ref<string | null>(null)

// Skip when no ID selected
const { data } = await useConvexQuery(
  api.posts.get,
  computed(() => selectedId.value ? { id: selectedId.value } : 'skip')
)
```

When args is `'skip'`:

- No subscription created
- `status` is `'idle'`
- `data` is `null`

When args becomes a real value, the subscription starts.

## When Subscriptions Don't Help

Real-time is powerful but not always needed. Consider disabling it:

```ts
const { data } = await useConvexQuery(
  api.blog.post,
  { slug },
  { subscribe: false }  // One-time fetch
)
```

**Disable subscriptions when:**

- Content rarely changes (blog posts, documentation)
- You want to reduce WebSocket traffic
- The query is expensive to run
- You're displaying historical/archived data

**Keep subscriptions when:**

- Multiple users might edit the same data
- You're building collaborative features
- The data changes frequently
- Real-time matters for UX (chat, dashboards, feeds)

## Under the Hood

The Convex client maintains a WebSocket connection to the server. When you subscribe:

1. Client sends subscription request with query ID and args
2. Server registers the subscription
3. Server runs query immediately, sends result
4. Server watches for database changes that affect the query
5. When changes occur, server re-runs query and sends new result

This is more efficient than polling because:

- No unnecessary requests when nothing changes
- Updates arrive immediately when something does change
- Server batches multiple updates efficiently

## Connection States

The WebSocket might disconnect (network issues, sleep, etc.). When it does:

1. Subscriptions pause
2. Client attempts reconnection with exponential backoff
3. When reconnected, subscriptions resume
4. Missed updates arrive automatically

Your code doesn't handle this. The module does.

You can monitor connection state:

```ts
const { isConnected, isReconnecting } = useConvexConnectionState()
```

See [Offline Indicator](/docs/patterns/offline-indicator) for UI patterns.

## Subscription Lifecycle

```
Component mounts
       ↓
useConvexQuery called
       ↓
Subscription created (or ref count incremented)
       ↓
Initial data arrives → data ref populated
       ↓
Updates arrive → data ref updated → component re-renders
       ↓
Component unmounts
       ↓
Ref count decremented
       ↓
If ref count = 0, subscription closed
```

Multiple components can share one subscription. Only when all are gone does it close.

## Debugging Subscriptions

Enable debug logging to see subscription activity:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  convex: {
    logging: {
      enabled: 'debug',
    },
  },
})
```

You'll see logs like:

```
[convex] Subscription created: api.todos.list {}
[convex] Subscription update: api.todos.list {} (3 items)
[convex] Subscription shared: api.todos.list {} (refCount: 2)
[convex] Subscription closed: api.todos.list {}
```

This helps you understand which queries are subscribed, how often they update, and when they're shared or closed.
