---
title: Auth Flow
description: Token lifecycle from login to API requests.
navigation:
  icon: i-lucide-key
---

Authentication with Convex involves several pieces: cookies, JWTs, tokens, and sessions. Here's how they connect.

## The Players

- **Better Auth**: Manages sessions, issues cookies
- **Session Cookie**: Browser stores this, sent with requests
- **JWT Token**: Convex uses this to verify identity
- **Nuxt Server**: Bridges cookies to tokens (in SSR mode)
- **Convex Server**: Validates tokens, runs queries/mutations

## Login Flow

When a user signs in:

```
1. User submits credentials
       ↓
2. Better Auth validates → creates session
       ↓
3. Session cookie set in browser
       ↓
4. Client exchanges cookie for JWT
       ↓
5. JWT stored in memory
       ↓
6. Convex client sends JWT with requests
```

```ts
// User clicks sign in
await authClient.signIn.email({
  email: 'user@example.com',
  password: 'password123',
})
// Cookie set automatically
// Token fetched automatically
// useConvexAuth() updates automatically
```

## SSR Flow

When a logged-in user visits a page (SSR mode):

```
1. Browser sends request with session cookie
       ↓
2. Nuxt server plugin reads cookie
       ↓
3. Server exchanges cookie for JWT via proxy
       ↓
4. Server runs queries with JWT
       ↓
5. HTML rendered with data
       ↓
6. JWT passed to client via hydration
       ↓
7. Client uses same JWT for WebSocket
```

The key insight: the server fetches the token so the client doesn't have to. Zero flash, no loading spinner for auth state.

## SPA Flow

Without SSR (`ssr: false`), simpler but more visible:

```
1. Page loads (no data yet)
       ↓
2. JavaScript runs
       ↓
3. Client checks for session cookie
       ↓
4. If found, exchanges for JWT
       ↓
5. Queries run with JWT
       ↓
6. Data renders
```

The user sees a loading state while auth resolves. Fine for dashboards, not great for marketing pages.

## Token Lifecycle

The JWT has an expiration. Here's how refresh works:

```
Token valid                    Token expires
    ↓                              ↓
Use for requests    →    Auto-refresh before expiry
    ↓                              ↓
Continue working            New token issued
```

The module handles this automatically. You don't refresh tokens manually.

If refresh fails (session expired, user logged out elsewhere):

```
Refresh fails
     ↓
Auth state clears
     ↓
isAuthenticated = false
     ↓
User redirected to login (by your middleware)
```

## The Proxy

In SSR mode, auth requests go through a Nuxt server route:

```
Browser → /api/auth/* → Nuxt Server → Convex HTTP Actions
```

Why? Cookies. The session cookie is httpOnly and scoped to your domain. The Nuxt server can read it and forward requests to Convex while preserving cookie handling.

```ts [server/routes/api/auth/[...path].ts]
export default defineEventHandler(async (event) => {
  const path = event.context.params?.path || ''
  const convexSiteUrl = process.env.CONVEX_SITE_URL

  return proxyRequest(event, `${convexSiteUrl}/api/auth/${path}`, {
    headers: {
      cookie: getHeader(event, 'cookie') || '',
    },
  })
})
```

## Token Contents

The JWT contains claims about the user:

```json
{
  "sub": "user_abc123",           // User ID (subject)
  "email": "user@example.com",
  "name": "Jane Doe",
  "iat": 1234567890,              // Issued at
  "exp": 1234571490               // Expires at
}
```

On the backend, you access this via `ctx.auth.getUserIdentity()`:

```ts
const identity = await ctx.auth.getUserIdentity()
// identity.subject = "user_abc123"
// identity.email = "user@example.com"
```

## Auth State on Client

The `useConvexAuth()` composable gives you:

```ts
const {
  isAuthenticated,  // User is logged in
  isPending,        // Auth still loading
  user,             // Decoded user info from JWT
  token,            // The actual JWT (rarely needed)
} = useConvexAuth()
```

- `isPending` is `true` on initial load until auth is determined
- `isAuthenticated` flips to `true` when a valid token exists
- `user` contains decoded JWT claims

## Caching

To avoid fetching tokens repeatedly:

**Client-side:**
- Token cached in memory
- Reused across page navigations
- Refreshed before expiry

**Server-side (optional):**
- Enable `authCache` for multi-request caching
- Reduces token exchanges on high-traffic pages
- Uses Nitro storage (memory or Redis)

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  convex: {
    authCache: {
      enabled: true,
      ttl: 900, // 15 minutes
    },
  },
})
```

## Logout Flow

When a user signs out:

```
1. authClient.signOut() called
       ↓
2. Better Auth invalidates session
       ↓
3. Session cookie cleared
       ↓
4. Client token cleared
       ↓
5. useConvexAuth() updates
       ↓
6. isAuthenticated = false
```

```ts
async function handleSignOut() {
  await authClient.signOut()
  // Auth state updates automatically
  navigateTo('/login')
}
```

## Security Notes

- **Cookies are httpOnly**: JavaScript can't read them (XSS protection)
- **Tokens are short-lived**: Limits damage if leaked
- **Server validates**: Never trust client-provided auth; always check `ctx.auth`
- **CORS configured**: `trustedOrigins` limits who can make auth requests

The cookie proves you have a session. The token proves you are who you claim. The server verifies both.
