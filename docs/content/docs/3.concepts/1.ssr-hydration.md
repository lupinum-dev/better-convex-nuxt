---
title: SSR & Hydration
description: How server rendering and WebSocket subscriptions work together.
navigation:
  icon: i-lucide-server
---

This module uses a hybrid approach: server-side rendering for the initial load, then WebSocket subscriptions for real-time updates. Understanding how these work together helps you make better choices about data loading.

## The Three Phases

When a user visits your page, three things happen in sequence:

```
1. Server Render    →    2. Client Hydration    →    3. Real-time Subscription
   (HTML with data)         (attach Vue)             (WebSocket updates)
```

### Phase 1: Server Render

The Nuxt server receives a request. If your query has `server: true`, it runs on the server:

1. Server plugin checks for session cookie
2. If found, exchanges it for a JWT token
3. Query runs via HTTP to Convex
4. Result embedded in HTML
5. HTML sent to browser

The user sees content immediately — no spinner, no loading state. Search engines see it too.

### Phase 2: Client Hydration

Vue takes over the server-rendered HTML:

1. JavaScript loads
2. Vue "hydrates" — attaches to existing DOM
3. Auth state transfers from server (via `useState`)
4. Convex client initializes

At this point, the app is interactive but not yet real-time.

### Phase 3: Real-time Subscription

The WebSocket connection establishes:

1. Convex client opens WebSocket
2. Query subscribes to updates
3. Future changes push to client automatically

Now if someone else modifies data, your UI updates without any code on your part.

## Why This Approach

Traditional SPAs work like this:

```
1. Load HTML shell    →    2. Load JavaScript    →    3. Fetch data    →    4. Render
   (empty page)              (wait...)               (wait more...)         (finally!)
```

Users see spinners. Search engines see nothing. Every navigation waits for data.

The hybrid approach inverts this:

- First visit: Data arrives *with* the HTML (no spinner)
- Client navigation: Can still be instant (with lazy loading)
- Real-time: After initial load, WebSocket handles updates
- SEO: Servers render content for crawlers

## When to Use SSR

Add `server: true` when:

- **SEO matters** — Product pages, blog posts, marketing content
- **First paint matters** — Hero sections, above-the-fold content
- **Data is the page** — Detail views where the whole point is the content

Skip server rendering when:

- **Personalized content** — User dashboards, recommendation feeds
- **Heavy queries** — Large data sets that slow the server
- **Client-only features** — Things that need browser APIs anyway

```ts
// SSR: Landing page hero section
const { data: featured } = await useConvexQuery(
  api.posts.featured,
  {},
  { server: true }
)

// Client-only: User-specific recommendations
const { data: forYou } = await useConvexQuery(
  api.posts.recommended,
  {},
  { server: false }  // or just omit server option
)
```

## Hydration Mismatches

When server and client render different content, Vue warns you. Common causes:

**Time-sensitive content:**

```ts
// Bad: Server and client have different times
const greeting = new Date().getHours() < 12 ? 'Good morning' : 'Good afternoon'

// Good: Compute on client only
const greeting = ref('')
onMounted(() => {
  greeting.value = new Date().getHours() < 12 ? 'Good morning' : 'Good afternoon'
})
```

**Auth state:**

```vue
<!-- Bad: Auth check runs differently on server vs client -->
<div>{{ user?.name || 'Guest' }}</div>

<!-- Good: Use ClientOnly for auth-dependent UI -->
<ClientOnly>
  <div>{{ user?.name || 'Guest' }}</div>
  <template #fallback>Loading...</template>
</ClientOnly>
```

**Random values:**

```ts
// Bad: Different on server and client
const id = Math.random().toString(36)

// Good: Generate once and share
const id = useState('random-id', () => Math.random().toString(36))
```

## The Cookie Bridge

For SSR with auth to work, the server needs to know who the user is. Here's how:

1. User logs in → Better Auth sets a session cookie
2. User visits page → Browser sends cookie with request
3. Nuxt server reads cookie → Exchanges for JWT via proxy
4. JWT used for server-side queries → Data returned
5. JWT passed to client → Client uses same token

This is why you need the [auth proxy](/docs/guide/auth#ssr-mode-requires-proxy) for SSR mode. It keeps the cookie flow working across domains.

## Performance Tradeoffs

SSR adds latency to the server response (Time to First Byte). You're trading:

| SSR | No SSR |
|-----|--------|
| Slower TTFB | Faster TTFB |
| Instant content | Spinner then content |
| Better SEO | Client-only rendering |
| More server load | Less server load |

For most apps, use SSR for important public pages and skip it for authenticated dashboards.

## Debugging

Enable logging to see what's happening:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  convex: {
    logging: {
      enabled: 'debug',
    },
  },
})
```

You'll see events like:

```
[convex] SSR fetch: api.posts.featured
[convex] Client hydrating auth state
[convex] WebSocket connected
[convex] Subscription started: api.posts.featured
```

This shows you the flow from server to client to real-time.
