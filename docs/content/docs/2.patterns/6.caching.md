---
title: Caching
description: Reuse data between pages for instant navigation.
navigation:
  icon: i-lucide-database
---

Ever notice how apps feel slow when you click a list item, wait for data, then click back and wait again? The data was right there. Let's keep it.

## The Problem

You have a list page and a detail page. Each loads its own data:

```vue [app/pages/posts/index.vue]
<script setup lang="ts">
// Load all posts (id, title, excerpt)
const { data: posts } = await useConvexQuery(api.posts.list, {})
</script>
```

```vue [app/pages/posts/[id].vue]
<script setup lang="ts">
// Load single post (id, title, excerpt, content, author...)
const { data: post } = await useConvexQuery(api.posts.get, { id: route.params.id })
</script>
```

When you navigate from list to detail, you wait. When you navigate back, you wait again. Even though you already had most of the data.

## The Solution

Use `lazy: true` with a `default` value from your cached data:

```vue [app/pages/posts/[id].vue]
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'

const route = useRoute()
const id = computed(() => route.params.id as string)

// Get cached post from the list query (if available)
const cachedPost = useNuxtData(`posts:${id.value}`)

// Load full post with cached data as default
const { data: post } = await useConvexQuery(
  api.posts.get,
  { id: id.value },
  {
    lazy: true, // Don't block navigation
    default: () => cachedPost.data.value ?? undefined,
  }
)
</script>

<template>
  <article>
    <h1>{{ post?.title }}</h1>
    <div v-html="post?.content ?? 'Loading...'" />
  </article>
</template>
```

Navigation is instant. The title shows immediately from cache. The full content loads in the background.

## Query Key Pattern

For this to work, your list page needs to cache posts by their ID:

```vue [app/pages/posts/index.vue]
<script setup lang="ts">
const { data: posts } = await useConvexQuery(api.posts.list, {}, { server: true })

// Cache each post by ID for detail pages
watchEffect(() => {
  posts.value?.forEach(post => {
    useNuxtData(`posts:${post._id}`).data.value = post
  })
})
</script>
```

Now when you navigate to `/posts/abc123`, the detail page can grab `posts:abc123` from the cache.

## Lightweight Lists

Your list query doesn't need everything. Fetch just what the list needs:

```ts [convex/posts.ts]
// For lists: just enough for cards
export const list = query({
  handler: async (ctx) => {
    const posts = await ctx.db.query('posts').collect()
    return posts.map(post => ({
      _id: post._id,
      title: post.title,
      excerpt: post.excerpt,
      createdAt: post.createdAt,
    }))
  },
})

// For detail: everything
export const get = query({
  args: { id: v.id('posts') },
  handler: async (ctx, args) => {
    return ctx.db.get(args.id)
  },
})
```

The list loads fast. The detail page shows the cached title while loading the full content.

## With SSR

Combine caching with server rendering for the best experience:

```vue [app/pages/posts/[id].vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => route.params.id as string)

const cachedPost = useNuxtData(`posts:${id.value}`)

const { data: post, pending } = await useConvexQuery(
  api.posts.get,
  { id: id.value },
  {
    server: true,    // SSR for direct visits
    lazy: true,      // Don't block client navigation
    default: () => cachedPost.data.value ?? undefined,
  }
)
</script>

<template>
  <article>
    <h1>{{ post?.title }}</h1>

    <!-- Show content or loading -->
    <div v-if="post?.content" v-html="post.content" />
    <div v-else-if="pending" class="content-skeleton">
      Loading full article...
    </div>
  </article>
</template>
```

- Direct visit (`/posts/abc123`): SSR fetches full post
- Navigation from list: shows cached title, loads content in background
- Either way: real-time updates keep it fresh

## Prefetching

For an even faster experience, prefetch on hover:

```vue [app/pages/posts/index.vue]
<script setup lang="ts">
const { data: posts } = await useConvexQuery(api.posts.list, {})

async function prefetch(id: string) {
  // Warm the cache
  await useConvexQuery(api.posts.get, { id }, { lazy: true })
}
</script>

<template>
  <NuxtLink
    v-for="post in posts"
    :key="post._id"
    :to="`/posts/${post._id}`"
    @mouseenter="prefetch(post._id)"
  >
    {{ post.title }}
  </NuxtLink>
</template>
```

When the user hovers, start loading. By the time they click, data's ready.

## Cache Invalidation

Convex's real-time subscriptions handle this for you. When data changes, all subscriptions update automatically.

If you've navigated away and back, the subscription picks up where it left off. Your cached data might be stale for a moment, but the real-time update arrives quickly.

For non-subscribed data, call `refresh()`:

```ts
const { data, refresh } = await useConvexQuery(
  api.posts.get,
  { id },
  { subscribe: false } // No WebSocket
)

// Manually refresh when needed
onMounted(() => {
  refresh()
})
```

## Full Pattern

List page with caching:

```vue [app/pages/posts/index.vue]
<script setup lang="ts">
const { data: posts, status } = await useConvexQuery(
  api.posts.list,
  {},
  { server: true }
)

// Cache posts for detail pages
watchEffect(() => {
  posts.value?.forEach(post => {
    useNuxtData(`posts:${post._id}`).data.value = post
  })
})
</script>

<template>
  <div v-if="status === 'pending'">Loading...</div>
  <div v-else>
    <NuxtLink
      v-for="post in posts"
      :key="post._id"
      :to="`/posts/${post._id}`"
      class="post-card"
    >
      <h2>{{ post.title }}</h2>
      <p>{{ post.excerpt }}</p>
    </NuxtLink>
  </div>
</template>
```

Detail page using cache:

```vue [app/pages/posts/[id].vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => route.params.id as string)

const cachedPost = useNuxtData(`posts:${id.value}`)

const { data: post, pending } = await useConvexQuery(
  api.posts.get,
  { id: id.value },
  {
    server: true,
    lazy: true,
    default: () => cachedPost.data.value ?? undefined,
  }
)
</script>

<template>
  <article>
    <NuxtLink to="/posts">Back to list</NuxtLink>

    <h1>{{ post?.title }}</h1>

    <div v-if="post?.content" v-html="post.content" />
    <div v-else-if="pending">
      <ContentSkeleton />
    </div>
  </article>
</template>
```

Navigation feels instant. The content you have shows immediately. The rest loads in the background.
