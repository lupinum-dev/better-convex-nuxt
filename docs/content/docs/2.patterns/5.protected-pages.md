---
title: Protected Pages
description: Guard routes with authentication and permissions.
navigation:
  icon: i-lucide-lock
---

Some pages are for everyone. Some require login. Some require specific roles. Here's how to protect them.

## Auth Middleware

Create a middleware that checks if the user is logged in:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated, isPending } = useConvexAuth()

  // Wait for auth to load
  if (isPending.value) {
    return
  }

  // Redirect if not logged in
  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }
})
```

Apply it to pages that need protection:

```vue [app/pages/dashboard.vue]
<script setup lang="ts">
definePageMeta({ middleware: 'auth' })
</script>

<template>
  <h1>Dashboard</h1>
  <!-- Only authenticated users see this -->
</template>
```

## Guest Middleware

The opposite: redirect logged-in users away from login pages:

```ts [app/middleware/guest.ts]
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated, isPending } = useConvexAuth()

  if (isPending.value) {
    return
  }

  // Already logged in? Go to dashboard
  if (isAuthenticated.value) {
    return navigateTo('/dashboard')
  }
})
```

```vue [app/pages/login.vue]
<script setup lang="ts">
definePageMeta({ middleware: 'guest' })
</script>

<template>
  <LoginForm />
</template>
```

## Permission Guards

For role-based access, use `usePermissionGuard`:

```vue [app/pages/admin/settings.vue]
<script setup lang="ts">
import { usePermissionGuard } from '~/composables/usePermissions'

// Redirects to /dashboard if user doesn't have permission
usePermissionGuard('settings.view', '/dashboard')
</script>

<template>
  <h1>Admin Settings</h1>
</template>
```

This works with the permission system from the [Permissions guide](/docs/guide/permissions).

## Middleware with Permissions

Create reusable middleware for common permission checks:

```ts [app/middleware/admin.ts]
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated, isPending } = useConvexAuth()

  if (isPending.value) {
    return
  }

  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }

  // Check role from permission context
  const { role } = usePermissions()
  if (role.value !== 'admin' && role.value !== 'owner') {
    return navigateTo('/dashboard')
  }
})
```

## Global Auth

Protect all pages by default, then opt out specific ones:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Public pages
    '/': { auth: false },
    '/login': { auth: false },
    '/signup': { auth: false },
    '/about': { auth: false },
    // Everything else requires auth
    '/**': { auth: true },
  },
})
```

Then read this in a global middleware:

```ts [app/middleware/auth.global.ts]
export default defineNuxtRouteMiddleware((to) => {
  // Check if route requires auth
  const requiresAuth = to.meta.auth !== false

  if (!requiresAuth) return

  const { isAuthenticated, isPending } = useConvexAuth()

  if (isPending.value) return

  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }
})
```

## Redirect After Login

Save where the user was trying to go:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to) => {
  const { isAuthenticated, isPending } = useConvexAuth()

  if (isPending.value) return

  if (!isAuthenticated.value) {
    // Save intended destination
    return navigateTo({
      path: '/login',
      query: { redirect: to.fullPath },
    })
  }
})
```

Then redirect back after login:

```vue [app/pages/login.vue]
<script setup lang="ts">
const route = useRoute()
const router = useRouter()
const authClient = useAuthClient()

async function handleLogin(email: string, password: string) {
  await authClient?.signIn.email({ email, password })

  // Go to intended page or dashboard
  const redirect = route.query.redirect as string
  router.push(redirect || '/dashboard')
}
</script>
```

## Conditional Content

Sometimes you want to show different content rather than redirect:

```vue
<script setup lang="ts">
const { isAuthenticated, user } = useConvexAuth()
</script>

<template>
  <div v-if="isAuthenticated">
    <p>Welcome, {{ user?.name }}!</p>
    <PrivateContent />
  </div>

  <div v-else>
    <p>Please log in to continue.</p>
    <NuxtLink to="/login">Sign In</NuxtLink>
  </div>
</template>
```

Or use the built-in components:

```vue
<template>
  <ConvexAuthenticated>
    <Dashboard />
  </ConvexAuthenticated>

  <ConvexUnauthenticated>
    <LoginPrompt />
  </ConvexUnauthenticated>
</template>
```

## SSR Considerations

Auth state is available on the server. Your middleware runs during SSR, so protected pages won't even render unauthorized HTML.

For client-only checks (like after a session expires), combine middleware with the `isPending` check to avoid flashing protected content:

```vue
<script setup lang="ts">
const { isPending, isAuthenticated } = useConvexAuth()
</script>

<template>
  <div v-if="isPending">
    <!-- Show nothing or skeleton while checking auth -->
  </div>
  <div v-else-if="isAuthenticated">
    <ProtectedContent />
  </div>
</template>
```

## Skip Auth for Performance

Public pages don't need auth checks. Skip them for faster loads:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  convex: {
    url: process.env.CONVEX_URL,
    skipAuthRoutes: [
      '/',
      '/about',
      '/blog/**',
      '/docs/**',
    ],
  },
})
```

Or per-page:

```vue [app/pages/about.vue]
<script setup lang="ts">
definePageMeta({
  skipConvexAuth: true,
})
</script>
```

This skips the token exchange, making these pages faster.
