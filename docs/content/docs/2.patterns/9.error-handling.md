---
title: Error Handling
description: Handle errors gracefully and keep users informed.
navigation:
  icon: i-lucide-alert-triangle
---

Errors happen. Networks fail, servers hiccup, sessions expire. Good error handling keeps your app working and users informed.

## Query Errors

Every query returns an `error` ref and a `refresh` function:

```vue
<script setup lang="ts">
const { data, status, error, refresh } = await useConvexQuery(api.posts.list, {})
</script>

<template>
  <div v-if="status === 'error'" class="error-state">
    <p>{{ error?.message || 'Something went wrong' }}</p>
    <button @click="refresh">Try again</button>
  </div>

  <div v-else-if="data">
    <!-- Render data -->
  </div>
</template>
```

The `refresh()` function re-runs the query. For transient errors (network blip), this usually works.

## Mutation Errors

Mutations give you two ways to handle errors:

**Using the error ref:**

```ts
const { mutate, error, reset } = useConvexMutation(api.posts.create)

async function handleSubmit() {
  await mutate({ title, content })

  if (error.value) {
    // Handle error
    console.error(error.value.message)
  }
}
```

**Using try-catch:**

```ts
const { mutate } = useConvexMutation(api.posts.create)

async function handleSubmit() {
  try {
    await mutate({ title, content })
    // Success
  } catch (err) {
    // Handle error
    console.error(err.message)
  }
}
```

Both work. Use the error ref for reactive UI updates, try-catch for flow control.

## Error Types

Convex errors typically fall into categories:

| Error | Cause | Recovery |
|-------|-------|----------|
| Network error | Connection lost | Retry, show offline indicator |
| Auth error | Session expired | Redirect to login |
| Validation error | Bad input | Show form error |
| Server error | Bug in your code | Show generic error, log it |
| Not found | Resource deleted | Navigate away or show message |

## Detecting Error Types

Check the error message to respond appropriately:

```ts
const { error } = await useConvexQuery(api.posts.get, { id })

watchEffect(() => {
  if (!error.value) return

  const message = error.value.message

  if (message.includes('Not authenticated') || message.includes('Unauthorized')) {
    navigateTo('/login')
  } else if (message.includes('Not found')) {
    navigateTo('/404')
  } else {
    // Generic error - maybe show a toast
    toast.error('Something went wrong')
  }
})
```

## Retry Pattern

For transient failures, implement retry with backoff:

```ts
const { data, error, refresh } = await useConvexQuery(api.posts.list, {})

const retryCount = ref(0)
const maxRetries = 3

async function retryWithBackoff() {
  if (retryCount.value >= maxRetries) {
    return // Give up
  }

  retryCount.value++
  const delay = Math.pow(2, retryCount.value) * 1000 // 2s, 4s, 8s

  await new Promise(resolve => setTimeout(resolve, delay))
  await refresh()

  if (!error.value) {
    retryCount.value = 0 // Reset on success
  }
}

// Auto-retry on error
watch(error, (err) => {
  if (err) retryWithBackoff()
})
```

## Form Validation Errors

For mutations with validation, show field-specific errors:

```vue
<script setup lang="ts">
const { mutate, error, pending, reset } = useConvexMutation(api.users.update)

const formErrors = computed(() => {
  if (!error.value) return {}

  const message = error.value.message

  // Parse validation errors from your backend
  if (message.includes('email')) {
    return { email: 'Invalid email address' }
  }
  if (message.includes('name')) {
    return { name: 'Name is required' }
  }

  return { general: message }
})

async function handleSubmit() {
  reset() // Clear previous errors
  await mutate({ name: name.value, email: email.value })
}
</script>

<template>
  <form @submit.prevent="handleSubmit">
    <div>
      <input v-model="name" placeholder="Name" />
      <span v-if="formErrors.name" class="error">{{ formErrors.name }}</span>
    </div>

    <div>
      <input v-model="email" placeholder="Email" />
      <span v-if="formErrors.email" class="error">{{ formErrors.email }}</span>
    </div>

    <span v-if="formErrors.general" class="error">{{ formErrors.general }}</span>

    <button :disabled="pending">Save</button>
  </form>
</template>
```

## Global Error Handler

Catch errors app-wide with a composable:

```ts [composables/useErrorHandler.ts]
export function useErrorHandler() {
  const toast = useToast()
  const router = useRouter()

  function handleError(error: Error) {
    const message = error.message

    // Auth errors
    if (message.includes('Not authenticated')) {
      router.push('/login')
      return
    }

    // Rate limiting
    if (message.includes('Too many requests')) {
      toast.error('Please slow down and try again')
      return
    }

    // Generic
    toast.error('Something went wrong. Please try again.')
    console.error(error)
  }

  return { handleError }
}
```

Use it in components:

```ts
const { handleError } = useErrorHandler()
const { mutate } = useConvexMutation(api.posts.create)

async function handleSubmit() {
  try {
    await mutate({ title, content })
  } catch (err) {
    handleError(err as Error)
  }
}
```

## Error Boundaries

For critical sections, wrap in error boundaries:

```vue [components/ErrorBoundary.vue]
<script setup lang="ts">
const error = ref<Error | null>(null)

onErrorCaptured((err) => {
  error.value = err
  return false // Don't propagate
})

function retry() {
  error.value = null
}
</script>

<template>
  <div v-if="error" class="error-boundary">
    <h3>Something went wrong</h3>
    <p>{{ error.message }}</p>
    <button @click="retry">Try again</button>
  </div>
  <slot v-else />
</template>
```

Use it:

```vue
<template>
  <ErrorBoundary>
    <PostList />
  </ErrorBoundary>
</template>
```

## Connection Errors

Handle WebSocket disconnection gracefully:

```vue
<script setup lang="ts">
const { isConnected, isReconnecting } = useConvexConnectionState()
</script>

<template>
  <div v-if="!isConnected" class="connection-warning">
    <span v-if="isReconnecting">Reconnecting...</span>
    <span v-else>You're offline. Changes will sync when you reconnect.</span>
  </div>
</template>
```

See [Offline Indicator](/docs/patterns/offline-indicator) for more patterns.

## User-Friendly Messages

Don't show raw error messages to users:

```ts
function formatError(error: Error): string {
  const message = error.message

  // Map technical errors to user-friendly messages
  const errorMap: Record<string, string> = {
    'Not authenticated': 'Please sign in to continue',
    'Not found': 'This item no longer exists',
    'Permission denied': "You don't have access to this",
    'Rate limit exceeded': 'Please wait a moment and try again',
    'Network error': 'Check your internet connection',
  }

  for (const [key, friendly] of Object.entries(errorMap)) {
    if (message.includes(key)) {
      return friendly
    }
  }

  // Generic fallback
  return 'Something went wrong. Please try again.'
}
```

## Logging Errors

In production, log errors for debugging:

```ts
function logError(error: Error, context?: Record<string, unknown>) {
  // Send to your error tracking service
  console.error('Error:', error.message, context)

  // Example with Sentry
  // Sentry.captureException(error, { extra: context })
}

// Use in error handlers
async function handleSubmit() {
  try {
    await mutate(data)
  } catch (err) {
    logError(err as Error, { action: 'createPost', data })
    toast.error('Failed to create post')
  }
}
```

## Full Pattern

Putting it all together:

```vue
<script setup lang="ts">
const { handleError } = useErrorHandler()
const { isConnected } = useConvexConnectionState()

const { data, status, error, refresh } = await useConvexQuery(
  api.posts.list,
  {},
  { server: true }
)

const { mutate, pending, error: mutationError, reset } = useConvexMutation(api.posts.create)

async function handleCreate() {
  reset()
  try {
    await mutate({ title: title.value })
    title.value = ''
  } catch (err) {
    handleError(err as Error)
  }
}
</script>

<template>
  <!-- Connection warning -->
  <div v-if="!isConnected" class="offline-banner">
    You're offline
  </div>

  <!-- Query error -->
  <div v-if="status === 'error'" class="error-state">
    <p>{{ formatError(error!) }}</p>
    <button @click="refresh">Retry</button>
  </div>

  <!-- Content -->
  <div v-else>
    <form @submit.prevent="handleCreate">
      <input v-model="title" :disabled="pending" />
      <button :disabled="pending">
        {{ pending ? 'Creating...' : 'Create' }}
      </button>
      <p v-if="mutationError" class="error">
        {{ formatError(mutationError) }}
      </p>
    </form>

    <PostCard v-for="post in data" :key="post._id" :post="post" />
  </div>
</template>
```

This gives you:
- Connection awareness
- Query error recovery
- Mutation error handling
- User-friendly messages
- Retry capability
