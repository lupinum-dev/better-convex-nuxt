---
title: Pagination
description: Load data in chunks with load more and infinite scroll.
navigation:
  icon: i-lucide-list
---

When you have a lot of data, you don't want to load it all at once. Pagination lets users load what they need, when they need it.

## Basic Setup

Use `useConvexPaginatedQuery` instead of `useConvexQuery`. It handles cursor management, page tracking, and merging results.

```vue
<script setup lang="ts">
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 10 }
)
</script>

<template>
  <div>
    <PostCard v-for="post in results" :key="post._id" :post="post" />

    <button
      v-if="status === 'CanLoadMore'"
      @click="loadMore(10)"
    >
      Load More
    </button>

    <p v-if="status === 'LoadingMore'">Loading...</p>
    <p v-if="status === 'Exhausted'">No more posts</p>
  </div>
</template>
```

The `results` array contains all loaded items, concatenated across pages. When you call `loadMore(10)`, it fetches the next 10 items and appends them.

## Status Values

| Status | Meaning |
|--------|---------|
| `LoadingFirstPage` | Initial load in progress |
| `CanLoadMore` | More data available |
| `LoadingMore` | Fetching next page |
| `Exhausted` | All data loaded |

Use these to show the right UI:

```vue
<template>
  <!-- Loading first page -->
  <div v-if="status === 'LoadingFirstPage'">
    <SkeletonCard v-for="i in 10" :key="i" />
  </div>

  <!-- Has data -->
  <div v-else>
    <PostCard v-for="post in results" :key="post._id" :post="post" />

    <!-- Load more button -->
    <button
      v-if="status === 'CanLoadMore'"
      @click="loadMore(10)"
      class="load-more"
    >
      Load More
    </button>

    <!-- Loading more -->
    <div v-if="status === 'LoadingMore'" class="loading">
      Loading more...
    </div>

    <!-- No more -->
    <div v-if="status === 'Exhausted'" class="end">
      You've reached the end
    </div>
  </div>
</template>
```

## Backend Query

Your Convex query needs to accept pagination options. Convex provides a validator and helpers:

```ts [convex/posts.ts]
import { query } from './_generated/server'
import { paginationOptsValidator } from 'convex/server'

export const list = query({
  args: {
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    return ctx.db
      .query('posts')
      .order('desc')
      .paginate(args.paginationOpts)
  },
})
```

The `paginate()` method returns `{ page, isDone, continueCursor }`. The composable handles these automatically.

## Infinite Scroll

Instead of a button, trigger `loadMore` when the user scrolls near the bottom:

```vue
<script setup lang="ts">
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  { initialNumItems: 20 }
)

// Trigger element at the bottom of the list
const loadTrigger = ref<HTMLElement>()

// Load more when trigger becomes visible
useIntersectionObserver(loadTrigger, ([entry]) => {
  if (entry.isIntersecting && status.value === 'CanLoadMore') {
    loadMore(20)
  }
})
</script>

<template>
  <div>
    <PostCard v-for="post in results" :key="post._id" :post="post" />

    <!-- Invisible trigger at the bottom -->
    <div ref="loadTrigger" class="h-1" />

    <div v-if="status === 'LoadingMore'" class="loading">
      Loading...
    </div>
  </div>
</template>
```

The `useIntersectionObserver` is from VueUse. When the trigger element enters the viewport, we load more.

## With Filters

Pass filter arguments alongside pagination. The composable handles re-fetching when filters change:

```vue
<script setup lang="ts">
const category = ref('all')

const { results, status, loadMore, reset } = await useConvexPaginatedQuery(
  api.posts.list,
  computed(() => ({
    category: category.value === 'all' ? undefined : category.value,
  })),
  { initialNumItems: 10 }
)

// Reset pagination when filter changes
watch(category, () => {
  reset()
})
</script>

<template>
  <select v-model="category">
    <option value="all">All</option>
    <option value="tech">Tech</option>
    <option value="design">Design</option>
  </select>

  <PostCard v-for="post in results" :key="post._id" :post="post" />

  <button v-if="status === 'CanLoadMore'" @click="loadMore(10)">
    Load More
  </button>
</template>
```

Call `reset()` to clear loaded pages and start fresh when filters change.

## SSR Support

Add `server: true` for server-side rendering of the first page:

```ts
const { results, status, loadMore } = await useConvexPaginatedQuery(
  api.posts.list,
  {},
  {
    initialNumItems: 10,
    server: true,  // SSR first page
  }
)
```

The first page renders on the server. Subsequent pages load on the client.

## Real-time Updates

Paginated queries stay real-time. If someone adds a post, it appears at the top of your list without refreshing. Deletions disappear automatically.

This works because each page maintains its own subscription. The first page updates in real-time while preserving the loaded pages below.

## Full Pattern

```vue
<script setup lang="ts">
const { results, status, loadMore, refresh, reset, isLoading } =
  await useConvexPaginatedQuery(
    api.posts.list,
    {},
    {
      initialNumItems: 20,
      server: true,
    }
  )

const loadTrigger = ref<HTMLElement>()

useIntersectionObserver(loadTrigger, ([entry]) => {
  if (entry.isIntersecting && status.value === 'CanLoadMore') {
    loadMore(20)
  }
})
</script>

<template>
  <div class="posts-feed">
    <!-- Loading first page -->
    <template v-if="status === 'LoadingFirstPage'">
      <SkeletonCard v-for="i in 6" :key="i" />
    </template>

    <!-- Content -->
    <template v-else>
      <PostCard
        v-for="post in results"
        :key="post._id"
        :post="post"
      />

      <!-- Load trigger for infinite scroll -->
      <div ref="loadTrigger" class="h-px" />

      <!-- Loading more -->
      <div v-if="status === 'LoadingMore'" class="py-4 text-center">
        <Spinner />
      </div>

      <!-- End of list -->
      <div v-if="status === 'Exhausted'" class="py-4 text-center text-gray-500">
        You've seen it all
      </div>
    </template>
  </div>
</template>
```

This gives you SSR for the first page, infinite scroll for loading more, real-time updates, and graceful end-of-list handling.
