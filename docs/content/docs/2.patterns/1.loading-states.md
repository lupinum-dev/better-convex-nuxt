---
title: Loading States
description: Show the right feedback at the right time.
navigation:
  icon: i-lucide-loader
---

Every query goes through states: waiting for data, receiving data, maybe hitting an error. How you handle these moments shapes how your app feels.

## The Status Ref

`useConvexQuery` gives you a `status` that's always one of four values:

| Status | Meaning |
|--------|---------|
| `idle` | Query is skipped (you passed `'skip'` as args) |
| `pending` | Waiting for data |
| `success` | Data arrived |
| `error` | Something went wrong |

There's also `pending` as a shorthand for `status === 'pending'`, which covers most cases.

```vue
<script setup lang="ts">
const { data, status, error } = await useConvexQuery(api.posts.list, {})
</script>

<template>
  <div v-if="status === 'pending'">Loading...</div>
  <div v-else-if="status === 'error'">{{ error?.message }}</div>
  <div v-else-if="!data?.length">No posts yet</div>
  <div v-else>
    <PostCard v-for="post in data" :key="post._id" :post="post" />
  </div>
</template>
```

Note the order matters. Check `pending` first, then `error`, then empty state, then render. If you check for empty data before pending, you'll flash "No posts" while loading.

## Skeletons vs Spinners

Spinners say "wait." Skeletons say "content is coming and it'll look like this."

Skeletons feel faster because they hint at the layout. Use them when you know the shape of what's loading. Use spinners for unknown or variable content.

```vue
<template>
  <div v-if="status === 'pending'" class="posts-grid">
    <!-- Same grid, skeleton cards -->
    <SkeletonCard v-for="i in 6" :key="i" />
  </div>
  <div v-else class="posts-grid">
    <PostCard v-for="post in data" :key="post._id" :post="post" />
  </div>
</template>
```

The trick is matching your skeleton to your real layout. If your grid has 3 columns, your skeleton should too. Layout shifts feel broken.

## SSR and ClientOnly

When you're server-rendering, the HTML arrives with data embedded — but only if the query ran on the server. For client-only queries, you need a fallback.

```vue
<template>
  <ClientOnly>
    <div v-if="status === 'pending'">
      <SkeletonCard v-for="i in 6" :key="i" />
    </div>
    <div v-else>
      <PostCard v-for="post in data" :key="post._id" :post="post" />
    </div>

    <!-- What to show during SSR -->
    <template #fallback>
      <SkeletonCard v-for="i in 6" :key="i" />
    </template>
  </ClientOnly>
</template>
```

The `#fallback` slot renders during SSR and until hydration completes. Without it, you get a blank space that pops into content.

## Blocking vs Non-blocking

By default, `await useConvexQuery()` blocks navigation until data loads. The user clicks a link, waits, then sees the page with data.

Add `lazy: true` to flip this: navigation happens immediately, and you show a loading state while data arrives.

```ts
// Blocks navigation
const { data } = await useConvexQuery(api.posts.get, { id })

// Instant navigation, shows loading state
const { data, pending } = await useConvexQuery(api.posts.get, { id }, { lazy: true })
```

Neither is better. It depends on the page.

**Block when:**
- The page makes no sense without the data
- It's a detail page where content is the whole point
- Load times are fast enough that blocking feels snappy

**Don't block when:**
- You can show a useful shell immediately
- The page has other content to show while loading
- You want navigation to feel instant

You can also combine them. Block for the main content, lazy-load the sidebar:

```vue
<script setup lang="ts">
// Primary content: block
const { data: post } = await useConvexQuery(api.posts.get, { id })

// Secondary content: don't block
const { data: related, pending } = await useConvexQuery(
  api.posts.related,
  { id },
  { lazy: true }
)
</script>

<template>
  <article>
    <h1>{{ post?.title }}</h1>
    <div v-html="post?.content" />
  </article>

  <aside>
    <div v-if="pending">Loading related...</div>
    <RelatedPosts v-else :posts="related" />
  </aside>
</template>
```

## Error States

Errors happen. Networks fail, sessions expire, servers hiccup. Don't just show "Error" — give people something to do.

```vue
<template>
  <div v-if="status === 'error'" class="error-state">
    <p>Couldn't load posts.</p>
    <button @click="refresh">Try again</button>
  </div>
</template>
```

The `refresh()` function re-runs the query. For transient errors (network blip), this usually works. For persistent errors (auth expired), you might redirect to login.

```ts
const { data, status, error, refresh } = await useConvexQuery(api.posts.list, {})

// Check error type and respond appropriately
watchEffect(() => {
  if (error.value?.message.includes('Unauthorized')) {
    navigateTo('/login')
  }
})
```

## Full Pattern

Putting it together:

```vue
<script setup lang="ts">
const { data: posts, status, error, refresh } = await useConvexQuery(
  api.posts.list,
  {},
  { server: true, lazy: true }
)
</script>

<template>
  <ClientOnly>
    <!-- Loading -->
    <div v-if="status === 'pending'" class="posts-grid">
      <SkeletonCard v-for="i in 6" :key="i" />
    </div>

    <!-- Error -->
    <div v-else-if="status === 'error'" class="error-state">
      <p>{{ error?.message || 'Something went wrong' }}</p>
      <button @click="refresh">Try again</button>
    </div>

    <!-- Empty -->
    <div v-else-if="!posts?.length" class="empty-state">
      <p>No posts yet.</p>
      <NuxtLink to="/posts/new">Create your first post</NuxtLink>
    </div>

    <!-- Content -->
    <div v-else class="posts-grid">
      <PostCard v-for="post in posts" :key="post._id" :post="post" />
    </div>

    <!-- SSR fallback -->
    <template #fallback>
      <div class="posts-grid">
        <SkeletonCard v-for="i in 6" :key="i" />
      </div>
    </template>
  </ClientOnly>
</template>
```

This handles every state: SSR, loading, error, empty, and success. The skeleton matches the real layout. Errors are actionable. Empty states guide users forward.
