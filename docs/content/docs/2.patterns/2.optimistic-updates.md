---
title: Optimistic Updates
description: Make your UI feel instant by predicting what the server will do.
navigation:
  icon: i-lucide-zap
---

When a user clicks "like" or adds an item to a list, they expect it to happen *now*. Not in 200ms when the server responds. Optimistic updates fake it until the server catches up.

The idea is simple: update the UI immediately with what you *think* will happen, then let the real server response replace your guess. If something goes wrong, roll back.

Convex handles the rollback automatically. You just tell it how to update the local cache.

## How It Works

1. User clicks a button
2. Your optimistic update runs — UI changes instantly
3. Mutation fires to the server
4. Server responds
5. Real data replaces your optimistic data (or rolls back on error)

The user sees step 2 immediately. Steps 3-5 happen in the background.

## Basic Example

Say you have a todo list. When someone adds a todo, you want it to appear instantly:

```ts
const { mutate: addTodo } = useConvexMutation(api.todos.create, {
  optimisticUpdate: (localStore, args) => {
    updateQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      updater: (current) => {
        const optimisticTodo = {
          _id: crypto.randomUUID() as Id<'todos'>,
          _creationTime: Date.now(),
          text: args.text,
          completed: false,
        }
        return current ? [optimisticTodo, ...current] : [optimisticTodo]
      },
    })
  },
})
```

The `localStore` is Convex's local cache of query results. You're telling it: "for this query with these args, here's what the data should look like right now."

When the server responds, it overwrites your optimistic todo with the real one (which has a real `_id` from the database). If the mutation fails, Convex removes your optimistic todo automatically.

## The Helpers

Four helpers cover most cases:

**`updateQuery`** — Modify a query result with a function. Use when you need the current value to compute the new one.

```ts
updateQuery({
  query: api.todos.list,
  args: {},
  localQueryStore: localStore,
  updater: (current) => current ? [newItem, ...current] : [newItem],
})
```

**`setQueryData`** — Replace a query result directly. Use when you know the exact new value.

```ts
setQueryData({
  query: api.users.get,
  args: { id: userId },
  localQueryStore: localStore,
  value: { ...currentUser, name: newName },
})
```

**`deleteFromQuery`** — Remove items from an array query. Cleaner than filtering manually.

```ts
deleteFromQuery({
  query: api.todos.list,
  args: {},
  localQueryStore: localStore,
  shouldDelete: (todo) => todo._id === deletedId,
})
```

**`updateAllQueries`** — Update every instance of a query. Use when the same data appears in multiple places.

```ts
updateAllQueries({
  query: api.users.get,
  localQueryStore: localStore,
  updater: (user) => user?._id === userId ? { ...user, name: newName } : user,
})
```

## Paginated Queries

Paginated queries have their own helpers because the data structure is different (multiple pages, continuation cursors, etc).

**`insertAtTop`** — Add an item to the beginning. Perfect for newest-first lists like feeds or chat.

```ts
insertAtTop({
  paginatedQuery: api.messages.list,
  localQueryStore: localStore,
  item: {
    _id: crypto.randomUUID() as Id<'messages'>,
    _creationTime: Date.now(),
    body: args.body,
    authorId: currentUser._id,
  },
})
```

**`deleteFromPaginatedQuery`** — Remove an item from paginated results.

```ts
deleteFromPaginatedQuery({
  paginatedQuery: api.messages.list,
  localQueryStore: localStore,
  shouldDelete: (msg) => msg._id === args.messageId,
})
```

**`optimisticallyUpdateValueInPaginatedQuery`** — Update items in place. Good for toggles, edits.

```ts
optimisticallyUpdateValueInPaginatedQuery({
  paginatedQuery: api.tasks.list,
  localQueryStore: localStore,
  updateValue: (task) =>
    task._id === args.taskId
      ? { ...task, completed: !task.completed }
      : task,
})
```

## Matching Your Query Shape

The optimistic item needs to match what your query returns. If your query returns `{ _id, text, completed, createdAt }`, your optimistic item needs all those fields.

```ts
// Your query returns this shape
type Todo = {
  _id: Id<'todos'>
  _creationTime: number
  text: string
  completed: boolean
  userId: Id<'users'>
}

// Your optimistic item needs the same shape
const optimisticTodo: Todo = {
  _id: crypto.randomUUID() as Id<'todos'>,
  _creationTime: Date.now(),
  text: args.text,
  completed: false,
  userId: currentUserId,  // Don't forget this
}
```

Missing fields cause type errors at best, weird UI bugs at worst.

## Matching Query Args

Your optimistic update targets a specific query + args combination. If the args don't match exactly, the update won't apply.

```ts
// This query...
const { data } = useConvexQuery(api.todos.list, { status: 'active' })

// ...needs this optimistic update
updateQuery({
  query: api.todos.list,
  args: { status: 'active' },  // Must match
  localQueryStore: localStore,
  updater: (current) => /* ... */,
})
```

If your app shows the same data with different filters, you might need multiple updates:

```ts
optimisticUpdate: (localStore, args) => {
  // Update the "all" list
  updateQuery({
    query: api.todos.list,
    args: {},
    localQueryStore: localStore,
    updater: (current) => current ? [newTodo, ...current] : [newTodo],
  })

  // Also update the "active" list if the new todo is active
  if (!args.completed) {
    updateQuery({
      query: api.todos.list,
      args: { status: 'active' },
      localQueryStore: localStore,
      updater: (current) => current ? [newTodo, ...current] : [newTodo],
    })
  }
}
```

## When Not to Bother

Optimistic updates add complexity. They're worth it when:

- The action is fast and almost always succeeds (adding to a list, toggling a boolean)
- Instant feedback matters (chat, collaborative editing, likes)
- The user is watching the result (they just clicked it)

They're probably not worth it when:

- The mutation might fail often (payment processing, complex validation)
- The result isn't visible immediately (background job, email sending)
- The mutation changes data in ways you can't predict client-side

A 200ms delay on "send email" is fine. A 200ms delay on "send message" feels sluggish.

## Full Example

A todo list with add, toggle, and delete — all optimistic:

```ts
const currentUserId = user.value?.id as Id<'users'>

// Add todo
const { mutate: addTodo } = useConvexMutation(api.todos.create, {
  optimisticUpdate: (localStore, args) => {
    updateQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      updater: (current) => {
        const optimistic = {
          _id: crypto.randomUUID() as Id<'todos'>,
          _creationTime: Date.now(),
          text: args.text,
          completed: false,
          userId: currentUserId,
        }
        return current ? [optimistic, ...current] : [optimistic]
      },
    })
  },
})

// Toggle completed
const { mutate: toggleTodo } = useConvexMutation(api.todos.toggle, {
  optimisticUpdate: (localStore, args) => {
    updateQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      updater: (current) =>
        current?.map(todo =>
          todo._id === args.id
            ? { ...todo, completed: !todo.completed }
            : todo
        ) ?? [],
    })
  },
})

// Delete
const { mutate: deleteTodo } = useConvexMutation(api.todos.delete, {
  optimisticUpdate: (localStore, args) => {
    deleteFromQuery({
      query: api.todos.list,
      args: {},
      localQueryStore: localStore,
      shouldDelete: (todo) => todo._id === args.id,
    })
  },
})
```

Each mutation updates the local cache immediately. The UI feels instant. Errors roll back automatically. The server stays the source of truth.
