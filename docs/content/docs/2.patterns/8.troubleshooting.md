---
title: Troubleshooting
description: Common issues and how to fix them.
navigation:
  icon: i-lucide-wrench
---

When things go wrong, check here first. These are the most common issues and their solutions.

## Query Runs Twice

**Symptom:** Your query appears to run once on the server and once on the client.

**Why:** This is normal SSR behavior. The server runs the query to render HTML, then the client runs it again to set up the WebSocket subscription.

**Solution:** This is expected. The client uses the server-fetched data immediately (no loading flash), then subscribes for future updates. If you want to avoid the client-side call entirely:

```ts
const { data } = await useConvexQuery(api.posts.list, {}, {
  server: true,
  subscribe: false,  // No WebSocket subscription
})
```

But you'll lose real-time updates. Usually, keep the default behavior.

---

## Data Flashes on Navigation

**Symptom:** When navigating between pages, you see a loading spinner or empty state briefly before data appears.

**Cause 1: Missing `server: true`**

Without SSR, data loads on the client after navigation:

```ts
// This loads after navigation
const { data } = await useConvexQuery(api.posts.list, {})

// This loads during SSR (no flash on direct visit)
const { data } = await useConvexQuery(api.posts.list, {}, { server: true })
```

**Cause 2: Not using caching pattern**

Even with SSR, client-side navigation can flash. Use the [caching pattern](/docs/patterns/caching):

```ts
const { data } = await useConvexQuery(api.posts.get, { id }, {
  server: true,
  lazy: true,
  default: () => cachedPost.value,  // Show cached data instantly
})
```

---

## Hydration Mismatch Warning

**Symptom:** Vue warns about hydration mismatch in the console.

**Cause:** Server and client rendered different content.

**Common triggers:**

**1. Time-sensitive content:**

```ts
// Bad: Different on server and client
const greeting = new Date().getHours() < 12 ? 'Morning' : 'Afternoon'

// Good: Compute on client only
const greeting = ref('')
onMounted(() => {
  greeting.value = new Date().getHours() < 12 ? 'Morning' : 'Afternoon'
})
```

**2. Auth-dependent UI without ClientOnly:**

```vue
<!-- Bad: Auth state differs during hydration -->
<div>{{ user?.name }}</div>

<!-- Good: Wrap in ClientOnly -->
<ClientOnly>
  <div>{{ user?.name }}</div>
  <template #fallback>Loading...</template>
</ClientOnly>
```

**3. Random values:**

```ts
// Bad: Different each render
const id = Math.random().toString(36)

// Good: Generate once
const id = useState('my-id', () => Math.random().toString(36))
```

---

## Auth Not Working in SSR

**Symptom:** User appears logged out during SSR even though they're authenticated.

**Cause 1: Missing proxy route**

SSR mode requires a proxy to forward auth requests. Create this file:

```ts [server/routes/api/auth/[...path].ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  const path = event.context.params?.path || ''
  const convexSiteUrl = config.public.convex?.siteUrl || process.env.CONVEX_SITE_URL

  return proxyRequest(event, `${convexSiteUrl}/api/auth/${path}`, {
    headers: {
      cookie: getHeader(event, 'cookie') || '',
    },
  })
})
```

**Cause 2: Wrong `siteUrl`**

Make sure `siteUrl` points to your Convex HTTP Actions URL (ends in `.convex.site`), not the WebSocket URL:

```ts [nuxt.config.ts]
convex: {
  url: 'https://your-app.convex.cloud',      // WebSocket
  siteUrl: 'https://your-app.convex.site',   // HTTP Actions (for auth)
}
```

**Cause 3: Cookie not being sent**

Check that cookies are being forwarded. In SSR, the session cookie must travel from browser → Nuxt server → Convex.

---

## WebSocket Won't Connect

**Symptom:** Real-time updates don't work. Console shows WebSocket errors.

**Cause 1: Wrong URL**

The `url` in config should be your Convex cloud URL:

```ts
convex: {
  url: 'https://your-app.convex.cloud',  // Not .site, not localhost
}
```

**Cause 2: Ad blocker or firewall**

Some ad blockers block WebSocket connections. Test in incognito mode.

**Cause 3: Mixed content**

If your site is HTTPS, the WebSocket URL must also be WSS (it is by default with Convex cloud URLs).

---

## "Not authenticated" Error

**Symptom:** Queries or mutations fail with authentication errors.

**On the backend:**

Make sure your query/mutation checks auth correctly:

```ts
export const myQuery = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error('Not authenticated')
    }
    // Continue...
  },
})
```

**On the frontend:**

Make sure you're authenticated before calling:

```ts
const { isAuthenticated } = useConvexAuth()

// Skip query if not authenticated
const { data } = await useConvexQuery(
  api.private.data,
  computed(() => isAuthenticated.value ? {} : 'skip')
)
```

---

## Query Returns `null` When Data Exists

**Symptom:** Your query returns null even though you can see data in the Convex dashboard.

**Cause 1: Wrong arguments**

Check that your args match what the query expects:

```ts
// If your query expects { id: Id<'posts'> }
const { data } = await useConvexQuery(api.posts.get, {
  id: route.params.id,  // Is this actually an ID string?
})
```

**Cause 2: Query logic**

Check your Convex query. Is it filtering correctly?

```ts
// Dashboard shows all posts, but query filters by user
export const myPosts = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    return ctx.db.query('posts')
      .filter(q => q.eq(q.field('userId'), identity?.subject))
      .collect()
  },
})
```

**Cause 3: Index not found**

If using `.withIndex()`, make sure the index exists in your schema.

---

## Mutation Succeeds But UI Doesn't Update

**Symptom:** Mutation completes without error, but the query data doesn't reflect changes.

**Cause 1: Different query args**

Optimistic updates target specific query + args combinations:

```ts
// Your query
const { data } = await useConvexQuery(api.todos.list, { status: 'active' })

// Your optimistic update must match
updateQuery({
  query: api.todos.list,
  args: { status: 'active' },  // Must match exactly
  localQueryStore: localStore,
  updater: (current) => /* ... */,
})
```

**Cause 2: No subscription**

If you used `subscribe: false`, the query won't update automatically:

```ts
const { data, refresh } = await useConvexQuery(api.todos.list, {}, {
  subscribe: false,
})

// You need to manually refresh
await mutate({ text: 'New todo' })
await refresh()  // Manually update
```

---

## "Cannot read property of null" on Page Load

**Symptom:** Error accessing data that should exist.

**Cause:** Accessing data before it loads.

**Solution:** Check for null/undefined:

```vue
<template>
  <!-- Bad: Crashes if data is null -->
  <div>{{ data.title }}</div>

  <!-- Good: Guard against null -->
  <div v-if="data">{{ data.title }}</div>

  <!-- Or use optional chaining -->
  <div>{{ data?.title }}</div>
</template>
```

---

## Slow Initial Load

**Symptom:** Page takes a long time to load initially.

**Cause 1: Too many SSR queries**

Each `server: true` query adds latency. Be selective:

```ts
// Critical content: SSR
const { data: post } = await useConvexQuery(api.posts.get, { id }, { server: true })

// Secondary content: client-side
const { data: related } = await useConvexQuery(api.posts.related, { id }, { lazy: true })
```

**Cause 2: Large data transfers**

Fetch only what you need:

```ts
// Instead of fetching entire documents
export const listPosts = query({
  handler: async (ctx) => {
    const posts = await ctx.db.query('posts').collect()
    // Return only needed fields
    return posts.map(p => ({
      _id: p._id,
      title: p.title,
      excerpt: p.content.slice(0, 200),
    }))
  },
})
```

**Cause 3: Auth token exchange**

Skip auth on public pages:

```ts [nuxt.config.ts]
convex: {
  skipAuthRoutes: ['/', '/blog/**', '/docs/**'],
}
```

---

## Environment Variables Not Working

**Symptom:** `process.env.CONVEX_URL` is undefined.

**In Nuxt config:**

Environment variables work directly:

```ts [nuxt.config.ts]
convex: {
  url: process.env.CONVEX_URL,  // Works
}
```

**In components:**

Use runtime config instead:

```ts
const config = useRuntimeConfig()
console.log(config.public.convex.url)
```

**On deployment:**

Make sure environment variables are set in your hosting platform (Vercel, Netlify, etc.), not just locally.

---

## Still Stuck?

1. **Enable debug logging:**

```ts [nuxt.config.ts]
convex: {
  logging: { enabled: 'debug' },
}
```

2. **Check the Convex Dashboard:** Look at Functions → Logs for backend errors.

3. **Check browser DevTools:** Network tab for failed requests, Console for errors.

4. **Minimal reproduction:** Create a minimal example that reproduces the issue. Often the problem becomes obvious.
