---
title: Permissions
description: Add role-based access control with ownership rules to your app.
navigation:
  icon: i-lucide-shield
---

This guide walks you through setting up role-based permissions with ownership rules. You'll learn how to control who can create, read, update, and delete resources based on their role.

::note
**Prerequisite:** Complete the [Authentication](/docs/guide/auth) guide first. You should have a working auth setup with a `users` table.
::

## What the Module Provides

When you enable `permissions: true` in your Nuxt config, the module provides **one thing**: the `createPermissions` factory function.

```ts
import { createPermissions } from '#imports'

export const { usePermissions, usePermissionGuard } = createPermissions({
  query: api.auth.getPermissionContext,  // Your Convex query
  checkPermission: (ctx, permission, resource) => { /* Your logic */ }
})
```

This gives you:
- **`usePermissions()`** - A composable that fetches permission context and provides a reactive `can()` function
- **`usePermissionGuard()`** - A composable that redirects users without permission

**Everything else is yours to define:** roles, permission rules, the `checkPermission` function, and backend authorization. The module just provides the reactive Vue wrapper.

::callout{icon="i-lucide-lightbulb"}
**Permissions are fully optional.** You don't need to use `createPermissions` at all. You can build your own permission system using plain `useConvexQuery` to fetch user roles and implement your own logic. This guide shows one approach, but feel free to adapt it or build something completely different.
::

::callout{icon="i-lucide-flask" color="amber"}
**Early-stage pattern.** This permission approach works well for our use cases, but we haven't battle-tested it on high-traffic production sites. Consider it a starting point that you should adapt to your needs. For complex multi-tenant apps, you may want a more sophisticated solution.
::

---

## What You'll Build

A permission system where:
- **Admins** can manage everything
- **Members** can create resources and edit their own
- **Viewers** have read-only access

The permission logic is **shared** between frontend and backend:

```text
┌───────────────────────────────────────────────────┐
│              permissions.config.ts                │
│         (shared permission definitions)           │
└───────────────────────┬───────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
        ▼                               ▼
┌───────────────────┐         ┌───────────────────┐
│     Frontend      │         │      Backend      │
│  usePermissions() │         │    authorize()    │
│  can('task.edit') │         │ Permission check  │
└───────────────────┘         └───────────────────┘
```

**Files you'll create:**

| File | Purpose |
|------|---------|
| `convex/permissions.config.ts` | Permission rules (shared) |
| `convex/lib/permissions.ts` | Backend authorization helpers |
| `convex/auth.ts` | Add permission context query |
| `composables/usePermissions.ts` | Frontend permission composable |

---

## Step 1: Add Role to Schema

Update your `users` table to include a `role` field.

```ts [convex/schema.ts]
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

const roleValidator = v.union(
  v.literal('admin'),
  v.literal('member'),
  v.literal('viewer'),
)

export default defineSchema({
  users: defineTable({
    authId: v.string(),
    displayName: v.optional(v.string()),
    email: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
    role: roleValidator,  // Add this!
    createdAt: v.number(),
    updatedAt: v.number()
  })
    .index('by_auth_id', ['authId'])
    .index('by_email', ['email']),

  // Example: Tasks with ownership
  tasks: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
    ownerId: v.string(),  // Track who created it
  })
    .index('by_owner', ['ownerId']),
});
```

Update your auth triggers to set a default role for new users:

```ts [convex/auth.ts]
// In your triggers.user.onCreate:
onCreate: async (ctx, doc) => {
  const now = Date.now()
  await ctx.db.insert('users', {
    authId: doc._id,
    displayName: doc.name,
    email: doc.email,
    avatarUrl: doc.image ?? undefined,
    role: 'member',  // Default role for new users
    createdAt: now,
    updatedAt: now
  })
}
```

---

## Step 2: Define Permission Rules

Create a shared permission config used by both frontend and backend.

```ts [convex/permissions.config.ts]
// Roles from most to least powerful
export const ROLES = ['admin', 'member', 'viewer'] as const
export type Role = (typeof ROLES)[number]

// Permission rules
// Simple: { roles: ['admin'] } - these roles can do it
// Ownership: { own: ['member'], any: ['admin'] } - members own stuff, admins any
export const permissions = {
  // Task permissions
  'task.create': { roles: ['admin', 'member'] },
  'task.read': { roles: ['admin', 'member', 'viewer'] },
  'task.update': { own: ['member'], any: ['admin'] },
  'task.delete': { own: ['member'], any: ['admin'] },

  // Settings (admin only)
  'settings.view': { roles: ['admin'] },
} as const

export type Permission = keyof typeof permissions

// The core check function - used by both frontend and backend
export function checkPermission(
  userRole: Role | null,
  userId: string | null,
  permission: Permission,
  resourceOwnerId?: string,
): boolean {
  if (!userRole) return false

  const rule = permissions[permission]

  // Simple permission check
  if ('roles' in rule) {
    return (rule.roles as readonly string[]).includes(userRole)
  }

  // Ownership permission check
  if ('any' in rule && (rule.any as readonly string[]).includes(userRole)) {
    return true
  }

  if ('own' in rule && (rule.own as readonly string[]).includes(userRole)) {
    return resourceOwnerId === userId
  }

  return false
}
```

**How permissions work:**

| Permission Rule | Meaning |
|-----------------|---------|
| `{ roles: ['admin', 'member'] }` | Admin or member can do it |
| `{ own: ['member'], any: ['admin'] }` | Members can do it to their own resources, admins to any |

---

## Step 3: Create Backend Helpers

Create utilities to enforce permissions in your Convex functions.

```ts [convex/lib/permissions.ts]
import type { QueryCtx, MutationCtx } from '../_generated/server'
import { checkPermission, type Permission, type Role } from '../permissions.config'

// Get the current user with their role
export async function getUser(ctx: QueryCtx | MutationCtx) {
  const identity = await ctx.auth.getUserIdentity()
  if (!identity) return null

  const user = await ctx.db
    .query('users')
    .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
    .first()

  return user
}

// Check permission and throw if denied
export async function authorize(
  ctx: QueryCtx | MutationCtx,
  permission: Permission,
  resourceOwnerId?: string,
) {
  const user = await getUser(ctx)
  if (!user) {
    throw new Error('Not authenticated')
  }

  const allowed = checkPermission(
    user.role as Role,
    user.authId,
    permission,
    resourceOwnerId
  )

  if (!allowed) {
    throw new Error(`Permission denied: ${permission}`)
  }

  return user
}
```

---

## Step 4: Add Permission Context Query

Add a query to your `convex/auth.ts` that returns the permission context for the frontend.

```ts [convex/auth.ts]
import { query } from './_generated/server'

// ... your existing auth setup ...

// Permission context query - called by usePermissions() on frontend
export const getPermissionContext = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) return null

    const user = await ctx.db
      .query('users')
      .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
      .first()

    if (!user) return null

    return {
      role: user.role,
      userId: user.authId,
    }
  },
})
```

---

## Step 5: Enable Permissions in Nuxt

Enable the permission composables in your module config:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['better-convex-nuxt'],

  convex: {
    url: process.env.CONVEX_URL,
    permissions: true,  // Enable createPermissions
  },
})
```

---

## Step 6: Create Frontend Composable

Use `createPermissions` to create your app's permission composable:

```ts [app/composables/usePermissions.ts]
import { createPermissions } from '#imports'
import { api } from '~~/convex/_generated/api'
import { checkPermission, type Permission, type Role } from '~~/convex/permissions.config'

export const { usePermissions, usePermissionGuard } = createPermissions<Permission>({
  query: api.auth.getPermissionContext,
  checkPermission: (ctx, permission, resource) => {
    if (!ctx) return false
    return checkPermission(
      ctx.role as Role,
      ctx.userId,
      permission,
      resource?.ownerId
    )
  },
})
```

---

## Step 7: Use Permissions in Backend

Update your Convex functions to use the `authorize` helper.

```ts [convex/tasks.ts]
import { mutation, query } from './_generated/server'
import { v } from 'convex/values'
import { authorize, getUser } from './lib/permissions'

export const get = query({
  handler: async (ctx) => {
    // Anyone authenticated can read
    const user = await getUser(ctx)
    if (!user) return []

    const tasks = await ctx.db.query('tasks').collect()

    // Get creator names for display
    return Promise.all(
      tasks.map(async (task) => {
        const creator = await ctx.db
          .query('users')
          .withIndex('by_auth_id', (q) => q.eq('authId', task.ownerId))
          .first()
        return {
          ...task,
          creatorName: creator?.displayName ?? 'Unknown',
        }
      })
    )
  },
})

export const create = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    // Check permission to create
    const user = await authorize(ctx, 'task.create')

    return ctx.db.insert('tasks', {
      text: args.text,
      isCompleted: false,
      ownerId: user.authId,  // Track owner for permission checks
    })
  },
})

export const update = mutation({
  args: { id: v.id('tasks'), text: v.string() },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    // Check permission - passes ownerId for ownership check
    await authorize(ctx, 'task.update', task.ownerId)

    await ctx.db.patch(args.id, { text: args.text })
  },
})

export const remove = mutation({
  args: { id: v.id('tasks') },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    await authorize(ctx, 'task.delete', task.ownerId)
    await ctx.db.delete(args.id)
  },
})
```

---

## Step 8: Use Permissions in Pages

### Conditional UI with `can()`

Use `usePermissions()` to show/hide UI elements based on permissions:

```vue [app/pages/tasks.vue]
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'
import { usePermissions } from '~/composables/usePermissions'

const { can, role } = usePermissions()
const { data: tasks } = await useConvexQuery(api.tasks.get, {}, { server: true })

const { mutate: createTask } = useConvexMutation(api.tasks.create)
const { mutate: deleteTask } = useConvexMutation(api.tasks.remove)

const newTaskText = ref('')

// can() returns a ComputedRef - Vue auto-unwraps in templates
const canCreateTask = can('task.create')
</script>

<template>
  <div>
    <p>Your role: <strong>{{ role }}</strong></p>

    <!-- Only show create form if user can create -->
    <form v-if="canCreateTask" @submit.prevent="createTask({ text: newTaskText })">
      <input v-model="newTaskText" placeholder="New task..." />
      <button type="submit">Add</button>
    </form>

    <ul>
      <li v-for="task in tasks" :key="task._id">
        {{ task.text }}
        <small>(by {{ task.creatorName }})</small>

        <!-- Pass the resource for ownership checks -->
        <button v-if="can('task.update', task).value">Edit</button>
        <button v-if="can('task.delete', task).value" @click="deleteTask({ id: task._id })">
          Delete
        </button>
      </li>
    </ul>
  </div>
</template>
```

::callout{icon="i-lucide-info"}
**Reactive by default:** `can()` returns a `ComputedRef<boolean>`. Vue auto-unwraps it in templates (`v-if="can('task.create')"`), but in script you need `.value` when passing the resource (`can('task.delete', task).value`).
::

### Page Protection with `usePermissionGuard()`

Protect entire pages from unauthorized access:

```vue [app/pages/settings.vue]
<script setup lang="ts">
import { usePermissionGuard } from '~/composables/usePermissions'

// Redirects to /tasks if user can't view settings
usePermissionGuard({ permission: 'settings.view', redirectTo: '/tasks' })
</script>

<template>
  <h1>Settings</h1>
  <!-- Only admins see this page -->
</template>
```

---

## Testing Permissions

:::warning{title="Development Only"}
The `switchRole` mutation below is for **development and testing only**. It allows users to change their own role, which is a security risk in production. The mutation includes a production safeguard that throws an error if executed in production, but you should **remove this entire mutation** before deploying to production.
:::

For development, add a mutation to switch roles:

```ts [convex/tasks.ts]
import { ROLES } from './permissions.config'

// DEV ONLY: Switch current user's role for testing
// ⚠️ REMOVE THIS MUTATION IN PRODUCTION - It's a security risk!
export const switchRole = mutation({
  args: { role: v.union(...ROLES.map(r => v.literal(r))) },
  handler: async (ctx, args) => {
    // Prevent execution in production
    if (process.env.NODE_ENV === 'production') {
      throw new Error('switchRole is disabled in production')
    }

    const user = await getUser(ctx)
    if (!user) throw new Error('Not authenticated')

    await ctx.db.patch(user._id, { role: args.role, updatedAt: Date.now() })
  },
})
```

Then add role switcher buttons to your page:

```vue
<script setup lang="ts">
import { ROLES } from '~~/convex/permissions.config'

const { mutate: switchRole } = useConvexMutation(api.tasks.switchRole)
const { role } = usePermissions()
</script>

<template>
  <div>
    Role:
    <button
      v-for="r in ROLES"
      :key="r"
      :disabled="role === r"
      @click="switchRole({ role: r })"
    >
      {{ r }}
    </button>
  </div>
</template>
```

---

## Verification Checklist

Test your implementation:

- [ ] Admin can create, edit, and delete any task
- [ ] Member can create tasks
- [ ] Member can edit/delete only their own tasks
- [ ] Viewer can only see tasks (no create/edit/delete buttons)
- [ ] Settings page redirects non-admins
- [ ] Backend rejects unauthorized mutations with "Permission denied"

---

## Final Structure

Here's the complete project structure after adding permissions.

::code-tree{defaultValue="convex/permissions.config.ts"}

```ts [convex/permissions.config.ts]
// Roles from most to least powerful
export const ROLES = ['admin', 'member', 'viewer'] as const
export type Role = (typeof ROLES)[number]

// Permission rules
export const permissions = {
  'task.create': { roles: ['admin', 'member'] },
  'task.read': { roles: ['admin', 'member', 'viewer'] },
  'task.update': { own: ['member'], any: ['admin'] },
  'task.delete': { own: ['member'], any: ['admin'] },
  'settings.view': { roles: ['admin'] },
} as const

export type Permission = keyof typeof permissions

export function checkPermission(
  userRole: Role | null,
  userId: string | null,
  permission: Permission,
  resourceOwnerId?: string,
): boolean {
  if (!userRole) return false

  const rule = permissions[permission]

  if ('roles' in rule) {
    return (rule.roles as readonly string[]).includes(userRole)
  }

  if ('any' in rule && (rule.any as readonly string[]).includes(userRole)) {
    return true
  }

  if ('own' in rule && (rule.own as readonly string[]).includes(userRole)) {
    return resourceOwnerId === userId
  }

  return false
}
```

```ts [convex/lib/permissions.ts]
import type { QueryCtx, MutationCtx } from '../_generated/server'
import { checkPermission, type Permission, type Role } from '../permissions.config'

export async function getUser(ctx: QueryCtx | MutationCtx) {
  const identity = await ctx.auth.getUserIdentity()
  if (!identity) return null

  const user = await ctx.db
    .query('users')
    .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
    .first()

  return user
}

export async function authorize(
  ctx: QueryCtx | MutationCtx,
  permission: Permission,
  resourceOwnerId?: string,
) {
  const user = await getUser(ctx)
  if (!user) {
    throw new Error('Not authenticated')
  }

  const allowed = checkPermission(
    user.role as Role,
    user.authId,
    permission,
    resourceOwnerId
  )

  if (!allowed) {
    throw new Error(`Permission denied: ${permission}`)
  }

  return user
}
```

```ts [convex/auth.ts]
import { createClient, type GenericCtx, type AuthFunctions } from '@convex-dev/better-auth'
import { convex } from '@convex-dev/better-auth/plugins'
import { betterAuth } from 'better-auth'
import { query } from './_generated/server'

import type { DataModel } from './_generated/dataModel'
import { components, internal } from './_generated/api'
import authConfig from './auth.config'

const siteUrl = process.env.SITE_URL!
const convexSiteUrl = process.env.CONVEX_SITE_URL!

const authFunctions: AuthFunctions = internal.auth

export const authComponent = createClient<DataModel>(components.betterAuth, {
  authFunctions,
  triggers: {
    user: {
      onCreate: async (ctx, doc) => {
        const now = Date.now()
        await ctx.db.insert('users', {
          authId: doc._id,
          displayName: doc.name,
          email: doc.email,
          avatarUrl: doc.image ?? undefined,
          role: 'member',
          createdAt: now,
          updatedAt: now
        })
      },
      onUpdate: async (ctx, newDoc, oldDoc) => {
        const nameChanged = newDoc.name !== oldDoc.name
        const emailChanged = newDoc.email !== oldDoc.email
        const imageChanged = newDoc.image !== oldDoc.image
        if (nameChanged || emailChanged || imageChanged) {
          const user = await ctx.db
            .query('users')
            .withIndex('by_auth_id', (q) => q.eq('authId', newDoc._id))
            .first()
          if (user) {
            await ctx.db.patch(user._id, {
              ...(nameChanged && { displayName: newDoc.name }),
              ...(emailChanged && { email: newDoc.email }),
              ...(imageChanged && { avatarUrl: newDoc.image ?? undefined }),
              updatedAt: Date.now()
            })
          }
        }
      },
      onDelete: async (ctx, doc) => {
        const user = await ctx.db
          .query('users')
          .withIndex('by_auth_id', (q) => q.eq('authId', doc._id))
          .first()
        if (user) {
          await ctx.db.delete(user._id)
        }
      }
    }
  }
})

export const createAuth = (ctx: GenericCtx<DataModel>) => {
  return betterAuth({
    baseURL: convexSiteUrl,
    database: authComponent.adapter(ctx),
    emailAndPassword: { enabled: true },
    plugins: [convex({ authConfig })],
    session: {
      expiresIn: 60 * 60 * 24 * 7,
      updateAge: 60 * 60 * 24
    },
    trustedOrigins: [siteUrl]
  })
}

export const getPermissionContext = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) return null

    const user = await ctx.db
      .query('users')
      .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
      .first()

    if (!user) return null

    return {
      role: user.role,
      userId: user.authId,
    }
  },
})

export const { onCreate, onUpdate, onDelete } = authComponent.triggersApi()
```

```ts [convex/schema.ts]
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

const roleValidator = v.union(
  v.literal('admin'),
  v.literal('member'),
  v.literal('viewer'),
)

export default defineSchema({
  users: defineTable({
    authId: v.string(),
    displayName: v.optional(v.string()),
    email: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
    role: roleValidator,
    createdAt: v.number(),
    updatedAt: v.number()
  })
    .index('by_auth_id', ['authId'])
    .index('by_email', ['email']),

  tasks: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
    ownerId: v.string(),
  })
    .index('by_owner', ['ownerId']),
});
```

```ts [convex/tasks.ts]
import { mutation, query } from './_generated/server'
import { v } from 'convex/values'
import { authorize, getUser } from './lib/permissions'
import { ROLES } from './permissions.config'

export const get = query({
  handler: async (ctx) => {
    const user = await getUser(ctx)
    if (!user) return []

    const tasks = await ctx.db.query('tasks').collect()

    return Promise.all(
      tasks.map(async (task) => {
        const creator = await ctx.db
          .query('users')
          .withIndex('by_auth_id', (q) => q.eq('authId', task.ownerId))
          .first()
        return {
          ...task,
          creatorName: creator?.displayName ?? 'Unknown',
        }
      })
    )
  },
})

export const create = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    const user = await authorize(ctx, 'task.create')

    return ctx.db.insert('tasks', {
      text: args.text,
      isCompleted: false,
      ownerId: user.authId,
    })
  },
})

export const update = mutation({
  args: { id: v.id('tasks'), text: v.string() },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    await authorize(ctx, 'task.update', task.ownerId)
    await ctx.db.patch(args.id, { text: args.text })
  },
})

export const remove = mutation({
  args: { id: v.id('tasks') },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    await authorize(ctx, 'task.delete', task.ownerId)
    await ctx.db.delete(args.id)
  },
})

// DEV ONLY: Switch current user's role for testing
// ⚠️ REMOVE THIS MUTATION IN PRODUCTION - It's a security risk!
export const switchRole = mutation({
  args: { role: v.union(...ROLES.map(r => v.literal(r))) },
  handler: async (ctx, args) => {
    // Prevent execution in production
    if (process.env.NODE_ENV === 'production') {
      throw new Error('switchRole is disabled in production')
    }

    const user = await getUser(ctx)
    if (!user) throw new Error('Not authenticated')

    await ctx.db.patch(user._id, { role: args.role, updatedAt: Date.now() })
  },
})
```

```ts [app/composables/usePermissions.ts]
import { createPermissions } from '#imports'
import { api } from '~~/convex/_generated/api'
import { checkPermission, type Permission, type Role } from '~~/convex/permissions.config'

export const { usePermissions, usePermissionGuard } = createPermissions<Permission>({
  query: api.auth.getPermissionContext,
  checkPermission: (ctx, permission, resource) => {
    if (!ctx) return false
    return checkPermission(
      ctx.role as Role,
      ctx.userId,
      permission,
      resource?.ownerId
    )
  },
})
```

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated, isPending } = useConvexAuth()

  if (isPending.value) {
    return
  }

  if (!isAuthenticated.value) {
    return navigateTo('/')
  }
})
```

```vue [app/pages/tasks.vue]
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'
import { usePermissions } from '~/composables/usePermissions'
import { ROLES } from '~~/convex/permissions.config'

const { can, role } = usePermissions()
const { data: tasks } = await useConvexQuery(api.tasks.get, {}, { server: true })

const { mutate: createTask } = useConvexMutation(api.tasks.create)
const { mutate: deleteTask } = useConvexMutation(api.tasks.remove)
const { mutate: switchRole } = useConvexMutation(api.tasks.switchRole)

const newTaskText = ref('')
const canCreateTask = can('task.create')
</script>

<template>
  <div>
    <div>
      Role:
      <button
        v-for="r in ROLES"
        :key="r"
        :disabled="role === r"
        @click="switchRole({ role: r })"
      >
        {{ r }}
      </button>
    </div>

    <form v-if="canCreateTask" @submit.prevent="createTask({ text: newTaskText })">
      <input v-model="newTaskText" placeholder="New task..." />
      <button type="submit">Add</button>
    </form>

    <ul>
      <li v-for="task in tasks" :key="task._id">
        {{ task.text }}
        <small>(by {{ task.creatorName }})</small>

        <button v-if="can('task.update', task).value">Edit</button>
        <button v-if="can('task.delete', task).value" @click="deleteTask({ id: task._id })">
          Delete
        </button>
      </li>
    </ul>
  </div>
</template>
```

```vue [app/pages/settings.vue]
<script setup lang="ts">
import { usePermissionGuard } from '~/composables/usePermissions'

usePermissionGuard({ permission: 'settings.view', redirectTo: '/tasks' })
</script>

<template>
  <h1>Settings</h1>
  <!-- Only admins see this page -->
</template>
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  compatibilityDate: '2025-07-15',
  devtools: { enabled: true },
  modules: ['better-convex-nuxt'],

  convex: {
    url: process.env.CONVEX_URL,
    permissions: true,
  },
})
```

::

---

## Next Steps

::card-group

::card
---
title: Permissions Reference
icon: i-lucide-book-open
to: /docs/auth-security/permissions
---
API reference for usePermissions, checkPermission, and advanced patterns.
::

::card
---
title: Organization Permissions
icon: i-lucide-building
to: /docs/auth-security/permissions-setup
---
Add multi-tenant organization support with owner, admin, member, viewer roles.
::

::card
---
title: Conditional Queries
icon: i-lucide-filter
to: /docs/data-fetching/queries#conditional-queries
---
Skip queries based on permissions for better performance.
::

::
