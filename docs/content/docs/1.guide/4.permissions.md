---
title: Permissions
description: Control who can do what in your app.
navigation:
  icon: i-lucide-shield
---

Authentication tells you *who* someone is. Permissions tell you *what they can do*. This guide adds role-based access control to your app: owners, admins, members, and viewers — each with different abilities.

::note
**Prerequisite:** Complete the [Authentication](/docs/guide/auth) guide first. You need a working auth system before adding permissions.
::

## The Plan

We'll build a permission system where:

- **Owners** control everything — settings, billing, members
- **Admins** manage content and invite people
- **Members** create and edit their own stuff
- **Viewers** can only read

The same permission rules work on both frontend (to show/hide UI) and backend (to actually enforce them). The backend is the source of truth — never trust the frontend alone.

## Update Your Schema

First, add roles to your users table. We'll use a simple `role` field.

```ts [convex/schema.ts] {4-9, 17}
import { defineSchema, defineTable } from 'convex/server'
import { v } from 'convex/values'

const roleValidator = v.union(
  v.literal('owner'),
  v.literal('admin'),
  v.literal('member'),
  v.literal('viewer'),
)

export default defineSchema({
  users: defineTable({
    authId: v.string(),
    displayName: v.optional(v.string()),
    email: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
    role: roleValidator,
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index('by_auth_id', ['authId'])
    .index('by_email', ['email']),

  // Your existing tables...
  tasks: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
    ownerId: v.string(), // Add this for ownership checks
  }),
})
```

::caution
If you already have creadted users account, you have to either migrate your users to new schema (add the role) or delete them.
Easiest way is just to delete the users from dashboard and recreate them afterwards.

✖ Schema validation failed.
Document with ID "012abc" in table "users" does not match the schema: Object is missing the required field `role`. Consider wrapping the field validator in `v.optional(...)` if this is expected.
::

Now update your auth trigger to assign a default role when users sign up:

```ts [convex/auth.ts]
// In your triggers.user.onCreate:
onCreate: async (ctx, doc) => {
  const now = Date.now()
  await ctx.db.insert('users', {
    authId: doc._id,
    displayName: doc.name,
    email: doc.email,
    avatarUrl: doc.image ?? undefined,
    role: 'member', // Default role for new users
    createdAt: now,
    updatedAt: now
  })
},
```

## Define Permission Rules

Create a configuration file that defines who can do what. This gets shared between frontend and backend.

```ts [convex/permissions.config.ts]
// Roles from most to least powerful
export const ROLES = ['owner', 'admin', 'member', 'viewer'] as const
export type Role = (typeof ROLES)[number]

// Permission rules
// Simple: { roles: ['owner', 'admin'] } - these roles can do it
// Ownership: { own: ['member'], any: ['admin'] } - members can do it to their own stuff, admins to anything
export const permissions = {
  // App-wide permissions
  'settings.view': { roles: ['owner'] },
  'settings.edit': { roles: ['owner'] },
  'members.invite': { roles: ['owner', 'admin'] },
  'members.remove': { roles: ['owner', 'admin'] },

  // Task permissions
  'task.create': { roles: ['owner', 'admin', 'member'] },
  'task.read': { roles: ['owner', 'admin', 'member', 'viewer'] },
  'task.update': { own: ['member'], any: ['owner', 'admin'] },
  'task.delete': { own: ['member'], any: ['owner', 'admin'] },
} as const

export type Permission = keyof typeof permissions

// The core check function - used by both frontend and backend
export function checkPermission(
  userRole: Role | null,
  userId: string | null,
  permission: Permission,
  resourceOwnerId?: string,
): boolean {
  if (!userRole) return false

  const rule = permissions[permission]

  // Simple permission check
  if ('roles' in rule) {
    return (rule.roles as readonly string[]).includes(userRole)
  }

  // Ownership permission check
  if ('any' in rule && (rule.any as readonly string[]).includes(userRole)) {
    return true
  }

  if ('own' in rule && (rule.own as readonly string[]).includes(userRole)) {
    return resourceOwnerId === userId
  }

  return false
}
```

## Backend Enforcement

Create a helper that checks permissions in your Convex functions. This is where security actually happens.

```ts [convex/lib/permissions.ts]
import type { QueryCtx, MutationCtx } from '../_generated/server'
import { checkPermission, type Permission, type Role } from '../permissions.config'

// Get the current user with their role
export async function getUser(ctx: QueryCtx | MutationCtx) {
  const identity = await ctx.auth.getUserIdentity()
  if (!identity) return null

  const user = await ctx.db
    .query('users')
    .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
    .first()

  return user
}

// Check permission and throw if denied
export async function authorize(
  ctx: QueryCtx | MutationCtx,
  permission: Permission,
  resourceOwnerId?: string,
) {
  const user = await getUser(ctx)
  if (!user) {
    throw new Error('Not authenticated')
  }

  const allowed = checkPermission(
    user.role as Role,
    user.authId,
    permission,
    resourceOwnerId
  )

  if (!allowed) {
    throw new Error(`Permission denied: ${permission}`)
  }

  return user
}
```

Now use it in your mutations:

```ts [convex/tasks.ts]
import { mutation, query } from './_generated/server'
import { v } from 'convex/values'
import { authorize, getUser } from './lib/permissions'

export const get = query({
  handler: async (ctx) => {
    // Anyone authenticated can read
    const user = await getUser(ctx)
    if (!user) return []

    return ctx.db.query('tasks').collect()
  },
})

export const create = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    // Check permission to create
    const user = await authorize(ctx, 'task.create')

    return ctx.db.insert('tasks', {
      text: args.text,
      isCompleted: false,
      ownerId: user.authId,
    })
  },
})

export const update = mutation({
  args: { id: v.id('tasks'), text: v.string() },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    // Check permission - passes ownerId for ownership check
    await authorize(ctx, 'task.update', task.ownerId)

    await ctx.db.patch(args.id, { text: args.text })
  },
})

export const remove = mutation({
  args: { id: v.id('tasks') },
  handler: async (ctx, args) => {
    const task = await ctx.db.get(args.id)
    if (!task) throw new Error('Task not found')

    await authorize(ctx, 'task.delete', task.ownerId)
    await ctx.db.delete(args.id)
  },
})
```

## Frontend Permissions

For the UI, we need a query that returns the user's permission context, and a composable to check permissions.

Add a query to return permission context:

```ts [convex/auth.ts]
import { query } from './_generated/server'

// Add this to your existing auth.ts
export const getPermissionContext = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) return null

    const user = await ctx.db
      .query('users')
      .withIndex('by_auth_id', q => q.eq('authId', identity.subject))
      .first()

    if (!user) return null

    return {
      role: user.role,
      userId: user.authId,
    }
  },
})
```

Enable permissions in your config:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['better-convex-nuxt'],
  convex: {
    url: process.env.CONVEX_URL,
    permissions: true, // Enable permission composables
  },
})
```

Create your permission composable:

```ts [app/composables/usePermissions.ts]
import { createPermissions } from '#imports'
import { api } from '~~/convex/_generated/api'
import { checkPermission, type Permission, type Role } from '~~/convex/permissions.config'

export const { usePermissions, usePermissionGuard } = createPermissions<Permission>({
  query: api.auth.getPermissionContext,
  checkPermission: (ctx, permission, resource) => {
    if (!ctx) return false
    return checkPermission(
      ctx.role as Role,
      ctx.userId,
      permission,
      resource?.ownerId
    )
  },
})
```

## Using Permissions in Components

Now you can show or hide UI based on permissions:

```vue [app/pages/tasks.vue]
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'
import { usePermissions } from '~/composables/usePermissions'

const { can, role } = usePermissions()
const { data: tasks } = await useConvexQuery(api.tasks.get, {}, { server: true })

const { mutate: createTask } = useConvexMutation(api.tasks.create)
const { mutate: deleteTask } = useConvexMutation(api.tasks.remove)

const newTaskText = ref('')
</script>

<template>
  <div>
    <p>Your role: {{ role }}</p>

    <!-- Only show create form if user can create -->
    <form v-if="can('task.create')" @submit.prevent="createTask({ text: newTaskText })">
      <input v-model="newTaskText" placeholder="New task..." />
      <button type="submit">Add</button>
    </form>

    <ul>
      <li v-for="task in tasks" :key="task._id">
        {{ task.text }}

        <!-- Show edit/delete only if user has permission for this specific task -->
        <button v-if="can('task.update', task)">Edit</button>
        <button v-if="can('task.delete', task)" @click="deleteTask({ id: task._id })">
          Delete
        </button>
      </li>
    </ul>
  </div>
</template>
```

The `can()` function is reactive. When you pass a resource (like `task`), it checks ownership rules automatically.

## Protecting Pages

Use `usePermissionGuard` to redirect users who shouldn't access a page:

```vue [app/pages/settings.vue]
<script setup lang="ts">
import { usePermissionGuard } from '~/composables/usePermissions'

// Redirects to /dashboard if user can't view settings
usePermissionGuard('settings.view', '/dashboard')
</script>

<template>
  <h1>Settings</h1>
  <!-- Only owners see this page -->
</template>
```

## Security Note

Frontend permission checks are for UX — showing the right buttons to the right people. Real security happens on the backend.

Always check permissions in your Convex functions. If someone crafts a request directly to your mutation, the frontend won't protect you. The `authorize()` helper ensures every mutation verifies permissions before doing anything.

```ts
// This is where security actually happens
const user = await authorize(ctx, 'task.delete', task.ownerId)
```

## Next Steps

You now have role-based permissions working across your full stack. Here's where to go next:

::card-group
::card
---
title: Deployment
icon: i-lucide-rocket
to: /docs/guide/deployment
---
Ship your app to production.
::
::card
---
title: Going Further
icon: i-lucide-arrow-right
to: /docs/guide/going-further
---
Explore patterns, concepts, and reference docs.
::
::card
---
title: Permissions Reference
icon: i-lucide-book-open
to: /docs/reference/use-permissions
---
Full API reference for permission composables.
::
::
