---
title: Basics
description: Master SSR, mutations, and real-time subscriptions.
navigation:
  icon: i-lucide-book-open
---

::note
**Prerequisite:** Complete the [Getting Started](/docs/guide/get-started) guide first. You should have a working Nuxt + Convex app with a tasks query.
::

Now that you have a basic query set up, let's explore what makes `better-convex-nuxt` special: **Granular control over data loading.**

We'll cover client-side loading, Server-Side Rendering (SSR), and mutations.

## Setup Navigation

To demonstrate the loading states effectively, we need a multi-page app. Let's restructure our application slightly.

::code-tree{defaultValue="app/pages/query.vue"}

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <nav>
      <NuxtLink to="/query">Go to Query Page</NuxtLink>
    </nav>
    <h1>Home Page</h1>
  </div>
</template>
```

```vue [app/pages/query.vue]
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'

// Default behavior: Client-side blocking
const { data: tasks, status, error } = await useConvexQuery(api.tasks.get, {})
</script>

<template>
  <NuxtLink to="/">Back Home</NuxtLink>
  <div>
    <p v-if="status === 'pending'">Loading...</p>
    <p v-else-if="error">Error: {{ error.message }}</p>
    <ul v-else>
      <li v-for="task in tasks" :key="task._id">{{ task.text }}</li>
    </ul>
  </div>
</template>
```

::

**Test it out:**
1. Go to `/` (Home).
2. Click "Go to Query Page".
3. Notice that navigation **waits** until the data is fetched (no "Loading..." text appears).
4. Refresh the page on `/query`. You will see "Loading..." briefly because it's fetching on the client side.

### Enable Server-Side Rendering (SSR)

To reduce loading spinners on the first load, we can enable [Server-Side Rendering](/docs/server-side/ssr-hydration).
(Downside of course of increased TTFB)

Update your query in `app/pages/query.vue`:

```ts {2}
const { data, status, error } = await useConvexQuery(api.tasks.get, {}, { 
  server: true // Enable SSR 
})
```

**Test it out:**
Refresh the page on `/query`. You should **not** see a loading state. The data is fetched on the server and sent to the client fully hydrated.

::tip
You can combine options! Use `{ lazy: true, server: true }` to render on the server for the first visit, but show a loading spinner immediately on client-side navigation instead of blocking.
::

## Add a Mutation

Even with `server: true`, `better-convex-nuxt` hydrates the state and establishes a WebSocket connection. This means your app remains **real-time**.

Let's add a mutation to create new tasks.

First, update your backend logic:

```ts [convex/tasks.ts] {11-23}
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const get = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("tasks").collect();
  },
});

// Add this mutation
export const create = mutation({
  args: {
    text: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("tasks", {
      text: args.text,
      isCompleted: false,
    });
  },
});
```

## Connect Mutation to UI

Update `app/pages/query.vue` to include a form. We will use `useConvexMutation` to handle the interaction.

```vue [app/pages/query.vue] {6-15, 22-33}
<script setup lang="ts">
import { api } from '~~/convex/_generated/api'

const { data: tasks, status, error } = await useConvexQuery(api.tasks.get, {}, { server: true })

// Setup mutation
const { mutate, pending, error: mutationError, reset } = useConvexMutation(api.tasks.create)
const taskText = ref('')

async function handleSubmit() {
  if (!taskText.value.trim()) return
  // Execute mutation
  await mutate({ text: taskText.value })
  taskText.value = ''
}
</script>

<template>
  <NuxtLink to="/">Home</NuxtLink>

  <div>
    <!-- Form Section -->
    <form @submit.prevent="handleSubmit">
      <input v-model="taskText" type="text" placeholder="Enter task..." :disabled="pending" />
      <button type="submit" :disabled="pending || !taskText.trim()">
        {{ pending ? 'Creating...' : 'Create Task' }}
      </button>
    </form>
    
    <div v-if="mutationError">
      <p>Something went wrong.</p>
      <button @click="reset">Dismiss</button>
    </div>

    <!-- List Section -->
    <p v-if="status === 'pending'">Loading...</p>
    <ul v-else>
      <li v-for="task in tasks" :key="task._id">{{ task.text }}</li>
    </ul>
  </div>
</template>
```

**Test it out:**
Add a task. It appears immediately! Open the app in a second browser window. When you add a task in one window, it instantly appears in the other.

## Manual Refresh (Opt-out of Real-time)

Sometimes you don't want a WebSocket connection (e.g., for static blog posts or expensive queries). You can [disable subscriptions](/docs/advanced/performance#disable-subscriptions) and control updates manually.

Change your query options:

```ts {3}
const { data, refresh } = await useConvexQuery(api.tasks.get, {}, { 
  server: true, 
  subscribe: false // Disable real-time updates
})
```

And add a refresh button to your template:

```html
<button @click="() => refresh()">Refresh List</button>
```

**Test it out:**
Add a task. The list **will not update**. Click "Refresh List" to fetch the new data manually.



## Next Steps

You have mastered the basics! Continue with authentication or explore advanced topics.

::card-group

::card
---
title: Authentication
icon: i-lucide-shield-check
to: /docs/guide/auth
---
Secure your app with Better Auth and protect your queries.
::

::card
---
title: Caching & Reuse
icon: i-lucide-database
to: /docs/data-fetching/caching-reuse
---
Reuse query data between pages for instant navigation.
::

::card
---
title: Optimistic UI
icon: i-lucide-zap
to: /docs/mutations/optimistic-updates
---
Make your app feel instant by predicting mutation results.
::

::card
---
title: Data Transforms
icon: i-lucide-wand-2
to: /docs/data-fetching/queries#transform-data
---
Transform and compute data before it reaches your component.
::

::